<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>English Practice</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    /* VS Code Dark+ inspired palette */
    :root {
      --page-bg-color: #1e1e1e;
      --bg: linear-gradient(180deg,#1e1e1e 0%, #181818 100%);
      --card-bg: #252526;
      --text: #d4d4d4;
      --muted: #9a9a9a;
      --primary: #569cd6; /* VSCode blue */
      --accent: #c586c0;  /* VSCode purple */
      --success: #6a9955;
      --error: #f44747;
      --glass: rgba(255,255,255,0.02);
      --shadow: 0 10px 26px rgba(0,0,0,0.6);
      --soft-shadow: 0 6px 14px rgba(0,0,0,0.5);
      --border: rgba(255,255,255,0.02);
      --radius: 12px;
    }
    /* light theme kept but tuned to be less bright and more contrasted */
    [data-theme="light"] {
      --page-bg-color: #f4f7fc;
      --bg: linear-gradient(180deg,#f6f9ff 0%, #eef6ff 100%);
      --card-bg: rgba(255,255,255,0.98);
      --text: #0f1724;
      --muted: #51637a;
      --primary: #2563eb;
      --accent: #7c3aed;
      --shadow: 0 12px 30px rgba(20,35,80,0.08);
      --soft-shadow: 0 6px 18px rgba(20,35,80,0.04);
      --border: rgba(16,24,40,0.06);
      --radius: 12px;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: 'Poppins', sans-serif; color: var(--text); background: var(--bg); min-height: 100vh; scroll-behavior: smooth; }
    .container { max-width: 1100px; margin: 36px auto; padding: 20px; }
    header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px; }
    .logo { width: 52px; height: 52px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: #071022; font-weight: 800; font-size: 1.1rem; box-shadow: var(--soft-shadow); }
    
    .control-panel { 
      display: flex; flex-wrap: wrap; gap: 8px; background: var(--card-bg);
      padding: 6px 8px; border-radius: calc(var(--radius) - 4px); box-shadow: var(--soft-shadow); margin-bottom: 12px; align-items: center; border: 1px solid rgba(255,255,255,0.03);
      font-size: 0.88rem; line-height: 1; 
    }
    .option-group { display: flex; align-items: center; gap: 8px; font-weight: 600; font-size: 0.86rem; border-right: 1px solid var(--border); padding-right: 8px; }
    .option-group:last-child { border-right: none; }
    
    select { flex: 1; min-width: 180px; padding: 10px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.03); background: var(--card-bg); color: var(--text); font-weight: 600; outline: none; box-shadow: none; }
    .btn { border: none; border-radius: 8px; padding: 10px 16px; font-weight: 700; cursor: pointer; transition: all 0.12s ease; background: linear-gradient(90deg,var(--primary),#4fc3f7); color: #0b1220; box-shadow: 0 6px 18px rgba(0,0,0,0.6); }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 10px 26px rgba(0,0,0,0.6); }
    .btn.ghost { background: transparent; border: 1px solid rgba(255,255,255,0.04); color: var(--primary); box-shadow: none; font-weight:700; }
    .btn.active-mode { background: linear-gradient(90deg,var(--success),#12c07a); color: white; }
    .btn.speaking-on { background: linear-gradient(90deg,#ff7a00,#ffb86b); color: white; box-shadow: 0 8px 28px rgba(255,124,0,0.18); }
    
    .exercise-item { background: var(--card-bg); padding: 26px; border-radius: var(--radius); box-shadow: var(--shadow); margin-bottom: 20px; border: 1px solid var(--border); animation: fadeIn 0.36s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
    
    .question { font-size: 1.18rem; font-weight: 700; margin-bottom: 10px; color: var(--text); letter-spacing: 0.2px; }
    .vietnamese { font-style: italic; color: var(--muted); border-left: 3px solid var(--primary); padding-left: 10px; margin-bottom: 15px; }
    .translation-hint { color: var(--primary); font-weight: 600; font-style: italic; display: block; margin-top: 8px; font-size: 0.95rem; }

    input[type="text"] { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.03); background: var(--card-bg); color: var(--text); font-size: 1.02rem; outline: none; transition: 0.18s; box-shadow: none; }
    input:focus { border-color: var(--primary); background: var(--card-bg); transform: translateY(-1px); }
    
    .feedback { margin-top: 15px; padding: 12px; border-radius: 8px; min-height: 20px; font-weight: 600; line-height: 1.5; }
    .feedback.success { color: var(--success); background: rgba(46, 204, 113, 0.1); }
    .feedback.error { color: var(--error); background: rgba(231, 76, 60, 0.1); }
    
    .tabs { display: flex; gap: 12px; margin-bottom: 20px; }
    .tab { padding: 10px 18px; border-radius: 12px; cursor: pointer; background: transparent; border: 1px solid transparent; color: var(--text); opacity:0.92; font-weight: 700; transition: all 0.12s ease; }
    .tab:hover { color: var(--text); transform: translateY(-2px); }
    .tab.active { background: linear-gradient(90deg,var(--primary),var(--accent)); color: white; border-color: transparent; box-shadow: 0 10px 30px rgba(37,99,235,0.12); }
    
    .pagination { display: flex; justify-content: center; align-items: center; gap: 20px; margin-top: 10px; padding-bottom: 40px; }
    
    #backToTop {
      position: fixed; bottom: 30px; right: 30px; width: 50px; height: 50px;
      background: var(--primary); color: white; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; box-shadow: var(--shadow); border: none;
      opacity: 0; visibility: hidden; transition: 0.3s; z-index: 1000; font-size: 1.2rem;
    }
    #backToTop.show { opacity: 1; visibility: visible; }
    .hide { display: none; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>
<body data-theme="light">
  <div class="container">
    <header>
      <div style="display:flex; align-items:center; gap:12px">
        <div class="logo">4S</div>
        <div>
          <h1 style="margin:0; font-size: 1.5rem;">Conversation Practice</h1>
          <p style="margin:0; font-size: 0.8rem; color: var(--text);">Listen - Speak - Read - Write</p>
        </div>
      </div>
      <div style="display:flex; gap:10px; align-items:center">
        <!-- Import JSON removed; lessons are loaded from json_list.json / LESSON/ -->
        <button class="btn ghost" id="themeToggle" title="Chuy·ªÉn giao di·ªán s√°ng/t·ªëi">üåô</button>
        <a class="btn ghost" href="test_offline.html" title="M·ªü H·ªçc Ngo·∫°i Ng·ªØ" style="margin-left:6px">H·ªçc Ngo·∫°i Ng·ªØ</a>
      </div>
    </header>

    <div class="tabs">
      <button class="tab active" id="tabListeningPreview" title="Ch·∫ø ƒë·ªô: Listening Preview">Listening Preview</button>
      <button class="tab" id="tabReading" title="Ch·∫ø ƒë·ªô: B√†i ƒë·ªçc (Reading Test)">Reading Test</button>
      <button class="tab" id="tabSentence" title="Ch·∫ø ƒë·ªô: Vi·∫øt c√¢u (Writing Test)">Writing Test</button>
    </div>

    <div id="exerciseArea"></div>

    <div id="pagination" class="pagination hide">
      <button class="btn ghost" id="prevEx" title="C√¢u tr∆∞·ªõc (Kh√¥ng √°p d·ª•ng cho Listening Test)">‚óÄ C√¢u tr∆∞·ªõc</button>
      <span id="pageInfo" style="font-weight: 600;">1 / 1</span>
      <button class="btn ghost" id="nextEx" title="C√¢u sau (Kh√¥ng √°p d·ª•ng cho Listening Test)">C√¢u sau ‚ñ∂</button>
    </div>

    <div class="control-panel">
      <div class="option-group" style="flex:1">
        <select id="lessonSelect"><option value="">-- Ch·ªçn b√†i h·ªçc --</option></select>
      </div>
      
      <div class="option-group">
        <span>Ngh·ªâ:</span>
        <input type="range" id="delayRange" min="0" max="5000" step="500" value="1000" title="Th·ªùi gian ch·ªù (ms) tr∆∞·ªõc khi chuy·ªÉn c√¢u sau khi ph√°t ƒë√°p √°n ‚Äî k√©o sang tr√°i ƒë·ªÉ nhanh h∆°n">
        <span id="delayVal">1.0s</span>
      </div>

      <div class="option-group">
        <span>ƒê·ªçc ƒë√°p √°n:</span>
        <select id="pauseSelect" style="padding:8px; border-radius:6px;" title="Th·ªùi gian (gi√¢y) ƒë·ªÉ ng∆∞·ªùi h·ªçc nghe/nh·∫Øc l·∫°i sau khi ƒë√°p √°n ƒë∆∞·ª£c ph√°t">
          <option value="0" selected>0s</option>
          <option value="1">1s</option>
          <option value="2">2s</option>
          <option value="3">3s</option>
          <option value="4">4s</option>
          <option value="5">5s</option>
        </select>
        <span id="statusLabel" style="margin-left:12px; font-weight:700; color:var(--text);">Tr·∫°ng th√°i: Idle</span>
      </div>

      <div class="option-group">
        <span>Preview ngh·ªâ:</span>
        <select id="listPauseSelect" style="padding:8px; border-radius:6px;" title="Th·ªùi gian (gi√¢y) gi·ªØa c√°c c√¢u khi nghe Preview">
          <option value="1">1s</option>
          <option value="2" selected>2s</option>
          <option value="3">3s</option>
          <option value="4">4s</option>
          <option value="5">5s</option>
        </select>
      </div>

      <div class="option-group">
        <label style="display:flex; align-items:center; gap:8px; font-weight:600;"><input type="checkbox" id="listLoopCheckbox"> T·ª± l·∫∑p l·∫°i</label>
      </div>

      <div class="option-group">
        <span>Audio Engine:</span>
        <select id="audioEngineSelect" style="padding:8px; border-radius:6px;">
          <option value="gTTS">gTTS (Female US)</option>
          <option value="Edge">Edge TTS (Male US)</option>
        </select>
      </div>

      <div class="option-group">
        <span>T·ª∑ l·ªá ƒë√∫ng:</span>
        <input type="range" id="thresholdRange" min="50" max="100" step="1" value="100" title="ƒêi·ªÅu ch·ªânh nh·∫≠n d·∫°ng ti·∫øng n√≥i (50% - d·ªÖ, 100% - ch√≠nh x√°c) T·∫≠p vi·∫øt n√™n ch·ªçn 100%">
        <span id="thresholdVal" style="margin-left:8px; font-weight:700;">100%</span>
        <span title="N·∫øu t·ª∑ l·ªá gi·ªëng (similarity) c·ªßa ph√°t √¢m so v·ªõi ƒë√°p √°n l·ªõn h∆°n ho·∫∑c b·∫±ng gi√° tr·ªã n√†y th√¨ s·∫Ω ƒë∆∞·ª£c ch·∫•m l√† ƒë√∫ng" style="margin-left:8px; color:var(--text);">‚ÑπÔ∏è</span>
      </div>

      <div class="option-group">
        <button class="btn ghost" id="toggleSkillMode" title="B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô luy·ªán n√≥i">üéôÔ∏è Luy·ªán N√≥i</button>
      </div>
      <div class="option-group">
        <span>Phi√™n:</span>
        <input type="number" id="sessionStartInput" min="1" value="1" style="width:70px; padding:6px; border-radius:6px;">
        <span> ƒë·∫øn </span>
        <input type="number" id="sessionEndInput" min="1" value="10" style="width:70px; padding:6px; border-radius:6px;">
        <button class="btn ghost" id="applySessionBtn" title="√Åp d·ª•ng ph·∫°m vi c√¢u cho phi√™n h·ªçc" style="margin-left:8px">√Åp d·ª•ng</button>
        <button class="btn ghost" id="bookmarkBtn" title="Bookmark v·ªã tr√≠ hi·ªán t·∫°i" style="margin-left:8px">üîñ L∆∞u</button>
        <button class="btn ghost" id="loadBookmarkBtn" title="T·∫£i bookmark" style="margin-left:6px">üìÇ T·∫£i</button>
      </div>
    </div>

    <!-- pagination moved above to sit directly under tabs -->
  </div>

  <button id="backToTop" title="L√™n ƒë·∫ßu trang">‚ñ≤</button>

  <script>
    let lessons = [];
    let currentLessonIdx = -1;
    let currentExIdx = 0;
    let isSingleMode = true;
    let isSpeakingMode = false; // d√πng cho luy·ªán n√≥i th·ª±c s·ª±
    // currentMode controls UI: 'sentence' or 'reading'
    let currentMode = 'listeningPreview'; // default to Listening Preview (home)
    let isReadingModeActive = false;
    let delayTimer = null;

    let recognition = null;
    let isRecognitionSupported = false;
    let willRestartRecognition = false;
    let pauseSeconds = 0; // seconds user can read answer (default 0s for immediate resume)
    let matchThreshold = 1.0; // similarity threshold (0..1), default 100% exact match
    // session controls: show only a range of sentences per study session
    let sessionStart = 0; // 0-based index
    let sessionEnd = 9;   // inclusive 0-based index; default show 1..10
    let sessionSize = 10;

    // Listening Preview state
    let listeningPauseSeconds = 2; // pause between sentences in preview (1..5)
    let listeningIndex = 0;
    let isPreviewPlaying = false;
    let listeningAutoLoop = false; // auto-loop session when reaching end
    let readingAutoLoop = false; // auto-loop for Reading Test
    let sentenceAutoLoop = false; // auto-loop for Sentence/Writing Test

    // Server lesson metadata and audio mapping
    let lessonsMeta = [];
    let audioMapping = [];
    let currentHowl = null;
    let ttsAudio = null; // track TTS Audio object for seeking/rewind
    let rewindSeconds = 3; // seconds to rewind when user requests

    // Load json_list.json to populate server lessons
    function loadLessonList() {
      fetch('json_list.json')
        .then(res => res.json())
        .then(data => {
          lessonsMeta = data.lessons || [];
          // remove previously appended remote options to avoid duplicates
          [...lessonSelect.querySelectorAll('option')].filter(o => o.value && o.value.startsWith('remote:')).forEach(o => o.remove());
          // append server lessons to lessonSelect
          lessonsMeta.forEach((m, i) => {
            const opt = document.createElement('option');
            opt.value = 'remote:' + i;
            opt.textContent = (m.name || '').replace('.json','');
            lessonSelect.appendChild(opt);
          });
        })
        .catch(err => console.log('Kh√¥ng th·ªÉ ƒë·ªçc json_list.json', err));
    }

    // Load a lesson JSON + mapping from LESSON/ folder
    function loadRemoteLesson(idx) {
      const meta = lessonsMeta[idx];
      if (!meta) return;
      fetch('LESSON/' + meta.name)
        .then(r => r.json())
        .then(data => {
          // convert array-of-arrays format into expected lesson object
          const lessonObj = { title: meta.name, fill: [], sentence: [] };
          if (Array.isArray(data)) {
            data.forEach((row, ridx) => {
              // row expected: [term, ipa, vi, example, example_ipa, example_vi]
                const front = (row[0] || '').toString().trim();
                const frontIpa = (row[1] || '').toString().trim();
                const frontVi = row[2] || '';
                const back = (row[3] || '').toString().trim();
                const backIpa = (row[4] || '').toString().trim();
                const backVi = row[5] || '';
                lessonObj.fill.push({ id: ridx, question: front, answer: front, hint_vi: frontVi, ipa: frontIpa });
                // If both front (question) and back (answer) exist and differ, create two practice items:
                // 1) practice the question line (user reads the question)
                // 2) practice the answer line (user reads the answer)
                if (front && back && front !== back) {
                  lessonObj.sentence.push({ id: ridx*2, prompt: front, answer: front, prompt_vi: frontVi, ipa: frontIpa });
                  lessonObj.sentence.push({ id: ridx*2 + 1, prompt: back, answer: back, prompt_vi: backVi, ipa: backIpa });
                } else {
                  // single-sentence format: use whichever text is present
                  const text = back || front || '';
                  const ipaText = back ? backIpa : frontIpa;
                  lessonObj.sentence.push({ id: ridx, prompt: text, answer: text, prompt_vi: backVi || frontVi, ipa: ipaText });
                }
            });
          } else {
            // if lesson is already in object format, try to use its fill/sentence
            lessonObj.fill = data.fill || data.items || [];
            lessonObj.sentence = data.sentence || [];
          }

          // load mapping
          if (meta.mapping) {
            fetch('LESSON/' + meta.mapping)
              .then(r => r.json())
              .then(map => {
                audioMapping = map || [];
              })
              .catch(e => { console.log('Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c mapping:', e); audioMapping = []; });
          } else {
            audioMapping = [];
          }

          // replace lessons with this remote lesson for convenience
          lessons = [lessonObj];
          currentLessonIdx = 0;
          currentExIdx = 0;
          render();
        })
        .catch(err => console.error('L·ªói khi t·∫£i b√†i h·ªçc:', err));
    }

    const lessonSelect = document.getElementById('lessonSelect');
    const exerciseArea = document.getElementById('exerciseArea');
    const delayRange = document.getElementById('delayRange');
    const skillBtn = document.getElementById('toggleSkillMode');

    delayRange.addEventListener('input', (e) => {
      document.getElementById('delayVal').textContent = (e.target.value / 1000).toFixed(1) + 's';
    });

    // thresholdRange controls fuzzy matching tolerance for correctness (50% - 100%)
    document.getElementById('thresholdRange').addEventListener('input', (e) => {
      const val = parseInt(e.target.value, 10) || 100;
      document.getElementById('thresholdVal').textContent = val + '%';
      matchThreshold = val / 100;
    });

    // pauseSelect controls how long to show answer after playback (1-5s)
    document.getElementById('pauseSelect').addEventListener('change', (e) => {
      pauseSeconds = parseInt(e.target.value, 10) || 2;
    });

    // Listening Preview pause select
    const listPauseSelect = document.getElementById('listPauseSelect');
    if (listPauseSelect) {
      listPauseSelect.addEventListener('change', (e) => {
        listeningPauseSeconds = parseInt(e.target.value, 10) || 2;
      });
    }

    // Listening Preview auto-loop checkbox
    const listLoopCheckbox = document.getElementById('listLoopCheckbox');
    if (listLoopCheckbox) {
      listLoopCheckbox.addEventListener('change', (e) => { listeningAutoLoop = !!e.target.checked; });
    }

    // keep global auto-loop checkbox as master: when changed, update other modes' loop flags and visible checkboxes
    if (listLoopCheckbox) {
      listLoopCheckbox.addEventListener('change', (e) => {
        const checked = !!e.target.checked;
        listeningAutoLoop = checked;
        readingAutoLoop = checked;
        sentenceAutoLoop = checked;
        // update visible controls if present
        const rcb = document.getElementById('readingLoopCheckbox'); if (rcb) rcb.checked = checked;
        const sb = document.getElementById('sentenceLoopCheckbox'); if (sb) sb.checked = checked;
        const lp = document.getElementById('lpAutoLoop'); if (lp) lp.checked = checked;
      });
    }

    // session apply / bookmark handlers
    document.getElementById('applySessionBtn').addEventListener('click', () => {
      const lesson = lessons[currentLessonIdx] || {};
      const total = (lesson.sentence || []).length || 0;
      let s = parseInt(document.getElementById('sessionStartInput').value, 10) || 1;
      let e = parseInt(document.getElementById('sessionEndInput').value, 10) || Math.min(s + sessionSize - 1, total);
      s = Math.max(1, Math.min(s, total));
      e = Math.max(s, Math.min(e, total));
      sessionStart = s - 1;
      sessionEnd = e - 1;
      sessionSize = sessionEnd - sessionStart + 1;
      currentExIdx = sessionStart;
      setStatus(`Phi√™n: ${s} - ${e}`, 'var(--muted)');
      if (currentMode === 'reading') renderReading(); else render();
    });

    document.getElementById('bookmarkBtn').addEventListener('click', () => {
      if (currentLessonIdx === -1) return setStatus('Kh√¥ng c√≥ b√†i ƒë·ªÉ bookmark', 'var(--error)');
      const lesson = lessons[currentLessonIdx];
      const key = `bookmark_${lesson.title || 'lesson'}`;
      const payload = {
        sessionStart: sessionStart,
        sessionEnd: sessionEnd,
        sessionSize: sessionSize,
        current: currentExIdx,
        threshold: Math.round(matchThreshold * 100),
        listeningAutoLoop: !!listeningAutoLoop,
        readingAutoLoop: !!readingAutoLoop,
        sentenceAutoLoop: !!sentenceAutoLoop,
        isSingleMode: !!isSingleMode,
        currentMode: currentMode || 'reading'
      };
      try {
        localStorage.setItem(key, JSON.stringify(payload));
        // also save a fallback last_bookmark for cross-page recovery
        try { localStorage.setItem('last_bookmark', JSON.stringify({ key, payload, page: window.location.pathname, ts: Date.now() })); } catch (e) { /* ignore */ }
        setStatus('ƒê√£ l∆∞u bookmark', 'green');
        console.log('Saved bookmark', key, payload);
      } catch (e) { setStatus('L∆∞u bookmark th·∫•t b·∫°i', 'var(--error)'); console.error('bookmark save error', e); }
    });

    document.getElementById('loadBookmarkBtn').addEventListener('click', () => {
      if (currentLessonIdx === -1) return setStatus('Kh√¥ng c√≥ b√†i ƒë·ªÉ t·∫£i bookmark', 'var(--error)');
      const lesson = lessons[currentLessonIdx];
      const key = `bookmark_${lesson.title || 'lesson'}`;
      try {
        let raw = localStorage.getItem(key);
        // fallback to last_bookmark if specific key not found
        if (!raw) {
          const last = localStorage.getItem('last_bookmark');
          if (last) {
            try {
              const parsedLast = JSON.parse(last);
              // if last_bookmark contains the same lesson key, use it; otherwise still allow user to restore
              raw = parsedLast && parsedLast.payload ? JSON.stringify(parsedLast.payload) : null;
              console.warn('Using fallback last_bookmark for restore');
            } catch (e) { /* ignore parse error */ }
          }
        }
        if (!raw) return setStatus('Kh√¥ng t√¨m th·∫•y bookmark', 'var(--muted)');
        const obj = JSON.parse(raw);
        sessionStart = (typeof obj.sessionStart === 'number') ? obj.sessionStart : 0;
        // restore sessionEnd and sessionSize if provided
        if (typeof obj.sessionEnd === 'number') {
          sessionEnd = Math.min(obj.sessionEnd, (lesson.sentence || []).length - 1);
        } else {
          sessionEnd = Math.min(sessionStart + sessionSize - 1, (lesson.sentence || []).length - 1);
        }
        sessionSize = (typeof obj.sessionSize === 'number') ? Math.max(1, Math.min(obj.sessionSize, (lesson.sentence || []).length)) : (sessionEnd - sessionStart + 1);
        currentExIdx = (typeof obj.current === 'number') ? obj.current : sessionStart;
        // update inputs (1-based)
        document.getElementById('sessionStartInput').value = sessionStart + 1;
        document.getElementById('sessionEndInput').value = sessionEnd + 1;
        // restore threshold if present
        if (typeof obj.threshold === 'number') {
          const perc = Math.max(50, Math.min(100, obj.threshold));
          document.getElementById('thresholdRange').value = perc;
          document.getElementById('thresholdVal').textContent = perc + '%';
          matchThreshold = perc / 100;
        }
        // restore auto-loop flags and UI state
        if (typeof obj.listeningAutoLoop === 'boolean') {
          listeningAutoLoop = obj.listeningAutoLoop;
          const globalAuto = document.getElementById('listLoopCheckbox'); if (globalAuto) globalAuto.checked = !!listeningAutoLoop;
        }
        if (typeof obj.readingAutoLoop === 'boolean') {
          readingAutoLoop = obj.readingAutoLoop;
          const readingCb = document.getElementById('readingLoopCheckbox'); if (readingCb) readingCb.checked = !!readingAutoLoop;
        }
        if (typeof obj.sentenceAutoLoop === 'boolean') {
          sentenceAutoLoop = obj.sentenceAutoLoop;
          const sentenceCb = document.getElementById('sentenceLoopCheckbox'); if (sentenceCb) sentenceCb.checked = !!sentenceAutoLoop;
        }
        if (typeof obj.isSingleMode === 'boolean') {
          isSingleMode = obj.isSingleMode;
          const viewBtn = document.getElementById('toggleViewMode'); if (viewBtn) {
            viewBtn.textContent = isSingleMode ? 'Ch·∫ø ƒë·ªô: C√¢u ƒë∆°n' : 'Ch·∫ø ƒë·ªô: T·∫•t c·∫£';
            viewBtn.classList.toggle('active-mode', !!isSingleMode);
          }
        }
        if (obj.currentMode) {
          currentMode = obj.currentMode;
          // update tab classes
          const tRead = document.getElementById('tabReading'); const tListen = document.getElementById('tabListeningPreview'); const tSent = document.getElementById('tabSentence');
          if (tRead) tRead.classList.toggle('active', currentMode === 'reading');
          if (tListen) tListen.classList.toggle('active', currentMode === 'listeningPreview');
          if (tSent) tSent.classList.toggle('active', currentMode === 'sentence');
        }
        setStatus('ƒê√£ t·∫£i bookmark', 'green');
        console.log('Loaded bookmark', key, obj);
        if (currentMode === 'reading') renderReading(); else render();
      } catch (e) { setStatus('T·∫£i bookmark l·ªói', 'var(--error)'); console.error('bookmark load error', e); }
    });

    function setStatus(text, color) {
      const el = document.getElementById('statusLabel');
      if (!el) return;
      el.textContent = 'Tr·∫°ng th√°i: ' + text;
      el.style.color = color || 'var(--muted)';
    }

    function initSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        alert("Tr√¨nh duy·ªát n√†y kh√¥ng h·ªó tr·ª£ luy·ªán n√≥i (Speech Recognition). Vui l√≤ng d√πng Google Chrome.");
        isRecognitionSupported = false;
        return;
      }
      isRecognitionSupported = true;
      recognition = new SpeechRecognition();
      recognition.lang = "en-US";
      recognition.continuous = false;
      recognition.interimResults = false;

      recognition.onresult = (event) => {
        const text = event.results[0][0].transcript;
        if (currentMode === 'reading' && isReadingModeActive) {
          handleReadingResult(text);
        } else {
          handleSpeechResult(text);
        }
      };

      recognition.onend = () => {
        if (isSpeakingMode || isReadingModeActive) {
          // n·∫øu ƒëang t·∫°m d·ª´ng v√¨ playback th√¨ kh√¥ng restart ·ªü ƒë√¢y
          if (willRestartRecognition) return;
          try {
            recognition.start();
          } catch (e) {
            console.log("Cannot restart recognition immediately:", e);
          }
        }
      };

      recognition.onerror = (event) => {
        console.log("Speech recognition error:", event.error);
      };
    }

    function cleanSpeech(str) {
      return str
        .toLowerCase()
        .replace(/\./g, "")              // b·ªè d·∫•u ch·∫•m
        .replace(/:/g, "")               // b·ªè d·∫•u :
        .replace(/a\s*m/g, "am")         // chu·∫©n h√≥a am
        .replace(/p\s*m/g, "pm")         // chu·∫©n h√≥a pm
        .replace(/(\d+)00/g, "$1")       // 7:00 ‚Üí 7
        .replace(/everyday/g, "every day") // s·ª≠a everyday ‚Üí every day
        .replace(/[^\w\s]/g, "")         // b·ªè k√Ω t·ª± ƒë·∫∑c bi·ªát
        .replace(/\s+/g, " ")            // chu·∫©n h√≥a kho·∫£ng tr·∫Øng
        .trim();
    }

    // Levenshtein distance for fuzzy matching
    function levenshtein(a, b) {
      const an = a ? a.length : 0;
      const bn = b ? b.length : 0;
      if (an === 0) return bn;
      if (bn === 0) return an;
      const matrix = Array.from({ length: bn + 1 }, (_, i) => new Array(an + 1));
      for (let i = 0; i <= bn; i++) matrix[i][0] = i;
      for (let j = 0; j <= an; j++) matrix[0][j] = j;
      for (let i = 1; i <= bn; i++) {
        for (let j = 1; j <= an; j++) {
          const cost = a[j - 1] === b[i - 1] ? 0 : 1;
          matrix[i][j] = Math.min(
            matrix[i - 1][j] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j - 1] + cost
          );
        }
      }
      return matrix[bn][an];
    }

    function similarity(a, b) {
      const s1 = cleanSpeech((a || '').toString());
      const s2 = cleanSpeech((b || '').toString());
      if (!s1 && !s2) return 1;
      const dist = levenshtein(s1, s2);
      const max = Math.max(s1.length, s2.length);
      return max === 0 ? 1 : Math.max(0, 1 - dist / max);
    }

    function startSpeechMode() {
      if (!recognition) {
        initSpeechRecognition();
      }
      if (!isRecognitionSupported) return;
      isSpeakingMode = true;
      // √©p v·ªÅ ch·∫ø ƒë·ªô c√¢u ƒë∆°n ƒë·ªÉ luy·ªán n√≥i theo t·ª´ng c√¢u
      if (!isSingleMode) {
        isSingleMode = true;
        const viewBtn = document.getElementById('toggleViewMode');
        viewBtn.textContent = 'Ch·∫ø ƒë·ªô: C√¢u ƒë∆°n';
        viewBtn.classList.add('active-mode');
      }
      currentExIdx = 0;
      render();
      try {
        recognition.start();
      } catch (e) {
        console.log("Recognition already started:", e);
      }
    }

    function stopSpeechMode() {
      isSpeakingMode = false;
      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.log("Error stopping recognition:", e);
        }
      }
      render();
    }

    function handleSpeechResult(text) {
      if (currentLessonIdx === -1) return;
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const item = data[currentExIdx];
      if (!item) return;

      const answer = item.answer_en || item.answer;
      const fb = document.getElementById(`fb_${currentExIdx}`);
      if (!fb) return;

      const clean = (str) => str.toLowerCase()
        .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()?"']/g,"")
        .replace(/\s{2,}/g," ")
        .trim();

      if (similarity(text, answer) >= matchThreshold) {
        const viTrans = item.prompt_vi || "";

        fb.className = 'feedback success';
        fb.innerHTML = `‚úÖ Ch√≠nh x√°c!${viTrans ? `<br><span class="translation-hint"> Nghƒ©a: ${viTrans}</span>` : ''}`;

        const textToSpeak = answer;
        playAudioFor(textToSpeak);

        clearTimeout(delayTimer);
        delayTimer = setTimeout(() => {
          if (currentExIdx < data.length - 1) {
            currentExIdx++;
            render();
          }
        }, parseInt(delayRange.value));
      } else {
        fb.className = 'feedback error';
        fb.innerHTML = `‚ùå B·∫°n n√≥i: "<span>${text}</span>"<br>ƒê√°p √°n ƒë√∫ng: ${answer}`;
        // ph√°t ƒë√°p √°n ƒë·ªÉ ng∆∞·ªùi h·ªçc c√≥ th·ªÉ nghe v√† nh·∫Øc l·∫°i
        playAudioFor(answer);
      }
    }

    function handleReadingResult(text) {
      if (currentLessonIdx === -1) return;
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const item = data[currentExIdx];
      if (!item) return;

      const expected = item.answer || item.prompt || '';
      const fb = document.getElementById('fb_reading');
      if (!fb) return;

      if (similarity(text, expected) >= matchThreshold) {
        fb.className = 'feedback success';
        fb.innerHTML = `‚úÖ Ch√≠nh x√°c!`;
        // play back correct answer then move to next
        playAudioFor(expected, () => {
          // advance to next sentence (respect sessionEnd)
            if (currentExIdx < sessionEnd) {
              currentExIdx = Math.min(sessionEnd, currentExIdx + 1);
              renderReading();
            } else {
            // finished
            if (readingAutoLoop) {
              // restart session
              currentExIdx = sessionStart;
              setStatus('T·ª± l·∫∑p l·∫°i (Looping)...', 'var(--accent)');
              // keep reading mode active and restart recognition
              if (!recognition) initSpeechRecognition();
              try { recognition && recognition.start(); } catch(e) { console.log('start recognition failed', e); }
              renderReading();
            } else {
              isReadingModeActive = false;
              setStatus('Ho√†n th√†nh', 'var(--success)');
              renderReading();
            }
          }
        });
      } else {
        fb.className = 'feedback error';
        fb.innerHTML = `‚ùå B·∫°n n√≥i: "<span>${text}</span>"`;
        // play correct answer for user to repeat
        playAudioFor(expected);
      }
    }

    skillBtn.addEventListener('click', () => {
      if (!isSpeakingMode) {
        skillBtn.textContent = 'üõë D·ª´ng Luy·ªán N√≥i';
        skillBtn.classList.add('speaking-on');
        startSpeechMode();
      } else {
        skillBtn.textContent = 'üéôÔ∏è Luy·ªán N√≥i';
        skillBtn.classList.remove('speaking-on');
        stopSpeechMode();
      }
    });

    const themeToggleBtn = document.getElementById('themeToggle');
    if (themeToggleBtn) {
      // initialize icon based on current theme
      const initIsLight = document.body.getAttribute('data-theme') === 'light';
      themeToggleBtn.textContent = initIsLight ? '‚òÄÔ∏è' : 'üåô';
      themeToggleBtn.addEventListener('click', () => {
        const isLight = document.body.getAttribute('data-theme') === 'light';
        const newTheme = isLight ? 'dark' : 'light';
        document.body.setAttribute('data-theme', newTheme);
        themeToggleBtn.textContent = newTheme === 'light' ? '‚òÄÔ∏è' : 'üåô';
      });
    }

    window.addEventListener('scroll', () => {
      document.getElementById('backToTop').classList.toggle('show', window.scrollY > 200);
    });
    document.getElementById('backToTop').addEventListener('click', () => window.scrollTo({top: 0}));

    // load server lessons list on startup
    loadLessonList();

    // initialize audio engine selector from localStorage
    const engineSel = document.getElementById('audioEngineSelect');
    if (engineSel) {
      const saved = localStorage.getItem('preferred_tts_engine');
      if (saved) engineSel.value = saved;
      engineSel.addEventListener('change', (e) => { localStorage.setItem('preferred_tts_engine', e.target.value); });
    }

    // Tab handlers for switching modes
    document.getElementById('tabSentence').addEventListener('click', () => {
      currentMode = 'sentence';
      document.getElementById('tabSentence').classList.add('active');
      document.getElementById('tabReading').classList.remove('active');
      isReadingModeActive = false;
      render();
    });

    document.getElementById('tabReading').addEventListener('click', () => {
      currentMode = 'reading';
      document.getElementById('tabReading').classList.add('active');
      document.getElementById('tabSentence').classList.remove('active');
      renderReading();
    });

    // Listening Preview tab
    const tabListeningPreview = document.getElementById('tabListeningPreview');
    if (tabListeningPreview) {
      tabListeningPreview.addEventListener('click', () => {
        currentMode = 'listeningPreview';
        // set active states
        tabListeningPreview.classList.add('active');
        document.getElementById('tabReading').classList.remove('active');
        document.getElementById('tabSentence').classList.remove('active');
        renderListeningPreview();
      });
    }

    lessonSelect.addEventListener('change', (e) => { 
      const v = e.target.value;
      if (!v) return;
      if (v.startsWith('remote:')) {
        const idx = parseInt(v.split(':')[1], 10);
        loadRemoteLesson(idx);
        return;
      }
      // local imported lessons (legacy behaviour)
      if (!isNaN(parseInt(v))) {
        currentLessonIdx = parseInt(v);
        currentExIdx = 0;
        render();
      }
    });
    
    // tabs removed: only Sentence writing supported

    function render() {
      // dispatch to specific renderers based on currentMode
      if (currentMode === 'reading') {
        renderReading();
        return;
      }
      if (currentMode === 'listeningPreview') {
        renderListeningPreview();
        return;
      }
      exerciseArea.innerHTML = '';
      if (currentLessonIdx === -1) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Vui l√≤ng ch·ªçn b√†i h·ªçc ƒë·ªÉ b·∫Øt ƒë·∫ßu.</div>';
        document.getElementById('pagination').classList.add('hide');
        return;
      }
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const total = data.length;
      // clamp session range
      sessionStart = Math.max(0, Math.min(sessionStart, Math.max(0, total - 1)));
      sessionEnd = Math.max(sessionStart, Math.min(sessionEnd, total - 1));

      // If in sentence/writing mode, show session controls (Restart + Auto-loop)
      if (currentMode === 'sentence') {
        const sessCtrl = document.createElement('div');
        sessCtrl.style.display = 'flex';
        sessCtrl.style.justifyContent = 'center';
        sessCtrl.style.gap = '10px';
        sessCtrl.style.marginBottom = '12px';
        sessCtrl.innerHTML = `
          <button class="btn ghost" id="sentenceRestart">B·∫Øt ƒë·∫ßu l·∫°i</button>
          <label style="display:flex; align-items:center; gap:8px; font-weight:600; margin-left:6px;"><input type="checkbox" id="sentenceLoopCheckbox"> T·ª± l·∫∑p l·∫°i</label>
        `;
        // insert at top
        exerciseArea.appendChild(sessCtrl);
        // wire events
        const restartBtn = document.getElementById('sentenceRestart');
        const loopCb = document.getElementById('sentenceLoopCheckbox');
        if (restartBtn) restartBtn.addEventListener('click', () => { currentExIdx = sessionStart; render(); });
        if (loopCb) { loopCb.checked = !!sentenceAutoLoop; loopCb.onchange = (e) => { sentenceAutoLoop = !!e.target.checked; const globalAuto = document.getElementById('listLoopCheckbox'); if (globalAuto) globalAuto.checked = e.target.checked; }; }
      }

      if (isSingleMode) {
        document.getElementById('pagination').classList.remove('hide');
        renderItem(data[currentExIdx], currentExIdx, total);
        const visibleCount = sessionEnd - sessionStart + 1;
        document.getElementById('pageInfo').textContent = `${currentExIdx - sessionStart + 1} / ${visibleCount} (t·ªïng ${total})`;
      } else {
        document.getElementById('pagination').classList.add('hide');
        // render only items in the session range
        for (let i = sessionStart; i <= sessionEnd; i++) {
          renderItem(data[i], i, total);
        }
      }
      
      const firstInput = exerciseArea.querySelector('input[type="text"], textarea, input[id^="input_"]');
      if (firstInput) {
        if (isSpeakingMode) {
          firstInput.placeholder = 'üé§ ƒêang nghe... h√£y n√≥i';
        } else {
          firstInput.placeholder = 'Nh·∫≠p c√¢u tr·∫£ l·ªùi...';
        }
        // delay focusing slightly to avoid being overridden by audio/recognition handlers
        setTimeout(() => {
          try { firstInput.focus(); if (typeof firstInput.select === 'function') firstInput.select(); } catch (e) { /* ignore */ }
        }, 50);
      }
    }

    function renderReading() {
      exerciseArea.innerHTML = '';
      if (currentLessonIdx === -1) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Vui l√≤ng Import ho·∫∑c ch·ªçn b√†i h·ªçc ƒë·ªÉ b·∫Øt ƒë·∫ßu Reading Test.</div>';
        document.getElementById('pagination').classList.add('hide');
        return;
      }
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const total = data.length;
      // clamp session range
      sessionStart = Math.max(0, Math.min(sessionStart, Math.max(0, total - 1)));
      sessionEnd = Math.max(sessionStart, Math.min(sessionEnd, total - 1));
      // ensure currentExIdx is within session
      currentExIdx = Math.max(sessionStart, Math.min(currentExIdx, sessionEnd));
      if (data.length === 0) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Kh√¥ng c√≥ c√¢u ƒë·ªÉ luy·ªán ƒë·ªçc trong b√†i h·ªçc n√†y.</div>';
        return;
      }
      document.getElementById('pagination').classList.remove('hide');
      const item = data[currentExIdx];
      const card = document.createElement('div');
      card.className = 'exercise-item';
      card.innerHTML = `
        <div style="font-size:1.6rem; font-weight:700; text-align:center; margin-bottom:16px;">${currentExIdx+1}. ${item.prompt || item.answer}</div>
        ${item.prompt_vi ? `<div class="vietnamese" style="text-align:center; opacity:0.75; font-size:0.95rem; margin-bottom:8px;">${item.prompt_vi}</div>` : ''}
        <div class="feedback" id="fb_reading"></div>
          <div style="text-align:center; margin-top:16px; display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap">
            <button class="btn ghost" id="readingToggle" title="B·∫Øt ƒë·∫ßu / D·ª´ng Reading Test">B·∫Øt ƒë·∫ßu Reading Test</button>
            <button class="btn ghost" id="readingRestart" title="B·∫Øt ƒë·∫ßu l·∫°i phi√™n">üîÅ B·∫Øt ƒë·∫ßu l·∫°i</button>
            <label style="display:flex; align-items:center; gap:8px; font-weight:600; margin-left:6px;"><input type="checkbox" id="readingLoopCheckbox"> T·ª± l·∫∑p l·∫°i</label>
          </div>
      `;
      exerciseArea.appendChild(card);

      const toggle = document.getElementById('readingToggle');
      toggle.addEventListener('click', () => {
        if (!isReadingModeActive) {
          // start reading
          if (!recognition) initSpeechRecognition();
          isReadingModeActive = true;
          setStatus('ƒêang nghe...', 'green');
          try { recognition.start(); } catch(e) { console.log('start recognition failed', e); }
          toggle.textContent = 'D·ª´ng Reading Test';
        } else {
          // stop reading
          isReadingModeActive = false;
          try { recognition.stop(); } catch(e) { console.log('stop recognition failed', e); }
          setStatus('Idle');
          toggle.textContent = 'B·∫Øt ƒë·∫ßu Reading Test';
        }
      });
      // reading restart and auto-loop
      const readingRestartBtn = document.getElementById('readingRestart');
      if (readingRestartBtn) {
        readingRestartBtn.addEventListener('click', () => {
          currentExIdx = sessionStart;
          // ensure reading mode is active and start recognition
          if (!isReadingModeActive) {
            isReadingModeActive = true;
            toggle.textContent = 'D·ª´ng Reading Test';
          }
          try { recognition && recognition.start(); } catch(e) { console.log('start recognition failed', e); }
          renderReading();
        });
      }
      const readingLoopCheckbox = document.getElementById('readingLoopCheckbox');
      if (readingLoopCheckbox) {
        // reflect current state when rendering (pre-check if previously enabled)
        readingLoopCheckbox.checked = !!readingAutoLoop;
        // assign onchange to avoid multiple listeners on repeated renders
        readingLoopCheckbox.onchange = (e) => { readingAutoLoop = !!e.target.checked; const globalAuto = document.getElementById('listLoopCheckbox'); if (globalAuto) globalAuto.checked = e.target.checked; };
      }
      const visibleCount = sessionEnd - sessionStart + 1;
      document.getElementById('pageInfo').textContent = `${currentExIdx - sessionStart + 1} / ${visibleCount} (t·ªïng ${total})`;
    }

    // Listening Preview renderer ‚Äî single live card only
    function renderListeningPreview() {
      exerciseArea.innerHTML = '';
      if (currentLessonIdx === -1) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Vui l√≤ng ch·ªçn b√†i h·ªçc ƒë·ªÉ b·∫Øt ƒë·∫ßu Listening Preview.</div>';
        document.getElementById('pagination').classList.add('hide');
        return;
      }
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const total = data.length;
      // clamp session range
      sessionStart = Math.max(0, Math.min(sessionStart, Math.max(0, total - 1)));
      sessionEnd = Math.max(sessionStart, Math.min(sessionEnd, total - 1));
      // ensure listeningIndex is within session
      listeningIndex = Math.max(sessionStart, Math.min(listeningIndex, sessionEnd));

      if (data.length === 0) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Kh√¥ng c√≥ c√¢u ƒë·ªÉ Preview trong b√†i h·ªçc n√†y.</div>';
        return;
      }

      document.getElementById('pagination').classList.remove('hide');

      // Controls (Prev / Rewind / Play / Next / Repeat)
      const ctrl = document.createElement('div');
      ctrl.style.display = 'flex';
      ctrl.style.justifyContent = 'center';
      ctrl.style.gap = '10px';
      ctrl.style.marginBottom = '12px';
      ctrl.innerHTML = `
        <button class="btn ghost" id="lpPrev" title="Lui (ArrowLeft)">‚óÄ Lui</button>
        <button class="btn ghost" id="lpRewind" title="L√πi 3s (ArrowUp)">‚è™ -3s</button>
        <button class="btn ghost" id="lpRestart" title="B·∫Øt ƒë·∫ßu l·∫°i phi√™n">üîÅ B·∫Øt ƒë·∫ßu l·∫°i</button>
        <button class="btn" id="lpPlay" title="Ph√°t hi·ªán t·∫°i (b·∫•m ph√≠m r ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i)">‚ñ∂ Ph√°t</button>
        <button class="btn ghost" id="lpNext" title="T·ªõi (ArrowRight)">T·ªõi ‚ñ∂</button>
        <button class="btn ghost" id="lpRepeat" title="L·∫∑p l·∫°i (ArrowDown)">üîÅ L·∫∑p l·∫°i</button>
        <label style="display:flex; align-items:center; gap:8px; margin-left:12px; font-weight:600;"><input type="checkbox" id="lpAutoLoop"> T·ª± l·∫∑p l·∫°i</label>
      `;
      exerciseArea.appendChild(ctrl);

      // Single live card showing the currently playing sentence
      const card = document.createElement('div');
      card.className = 'exercise-item';
      card.id = 'lp_current_card';
      card.innerHTML = `
        <div id="lp_eng" style="font-size:1.2rem; font-weight:700; color:var(--text);"></div>
        <div id="lp_ipa" style="font-size:0.98rem; font-style:italic; color:var(--muted); margin-top:8px;"></div>
        <div id="lp_vn" style="font-size:0.98rem; color:var(--primary); margin-top:8px;"></div>
      `;
      exerciseArea.appendChild(card);
      // center content for better readability
      card.style.display = 'flex';
      card.style.flexDirection = 'column';
      card.style.alignItems = 'center';
      card.style.justifyContent = 'center';
      card.style.textAlign = 'center';
      card.style.minHeight = '120px';

      updateListeningCard(listeningIndex);

      document.getElementById('pageInfo').textContent = `${listeningIndex - sessionStart + 1} / ${sessionEnd - sessionStart + 1} (t·ªïng ${total})`;

      // hook controls
      const prevBtn = document.getElementById('lpPrev');
      const nextBtn = document.getElementById('lpNext');
      const repBtn = document.getElementById('lpRepeat');
      const playBtn = document.getElementById('lpPlay');
      const rewindBtn = document.getElementById('lpRewind');
      const restartBtn = document.getElementById('lpRestart');

      prevBtn.addEventListener('click', () => { if (listeningIndex > sessionStart) { listeningIndex--; updateListeningCard(listeningIndex); playPreviewAt(listeningIndex, false); } });
      if (rewindBtn) rewindBtn.addEventListener('click', () => { rewindPreview(rewindSeconds); });
      if (restartBtn) restartBtn.addEventListener('click', () => { listeningIndex = sessionStart; updateListeningCard(listeningIndex); playPreviewAt(listeningIndex, true); const pb = document.getElementById('lpPlay'); if (pb) pb.textContent = '‚è∏ D·ª´ng'; });
      nextBtn.addEventListener('click', () => { if (listeningIndex < sessionEnd) { listeningIndex++; updateListeningCard(listeningIndex); playPreviewAt(listeningIndex, false); } });
      repBtn.addEventListener('click', () => { playPreviewAt(listeningIndex, false); });
      playBtn.addEventListener('click', () => { if (!isPreviewPlaying) { playPreviewAt(listeningIndex, true); playBtn.textContent = '‚è∏ D·ª´ng'; } else { stopPreviewPlayback(); playBtn.textContent = '‚ñ∂ Ph√°t'; } });

      // sync the local Listening Preview auto-loop checkbox with the global control
      const lpAuto = document.getElementById('lpAutoLoop');
      const globalAuto = document.getElementById('listLoopCheckbox');
      if (lpAuto) {
        lpAuto.checked = !!listeningAutoLoop || (globalAuto && globalAuto.checked);
        lpAuto.addEventListener('change', (e) => {
          listeningAutoLoop = !!e.target.checked;
          if (globalAuto) globalAuto.checked = e.target.checked;
        });
      }
      if (globalAuto) {
        // keep local checkbox in sync when global toggles
        globalAuto.addEventListener('change', (e) => {
          listeningAutoLoop = !!e.target.checked;
          if (lpAuto) lpAuto.checked = e.target.checked;
        });
      }
    }

    function highlightListeningItem(idx) {
      // For single-card preview, update the displayed card
      updateListeningCard(idx);
    }

    function updateListeningCard(idx) {
      const lesson = lessons[currentLessonIdx] || {};
      const data = lesson.sentence || [];
      const item = data[idx] || {};
      const engEl = document.getElementById('lp_eng');
      const ipaEl = document.getElementById('lp_ipa');
      const vnEl = document.getElementById('lp_vn');
      if (engEl) {
        engEl.innerHTML = `${idx+1}. ${item.prompt || item.answer || ''}`;
        engEl.style.textAlign = 'center';
        engEl.style.fontSize = '1.25rem';
      }
      if (ipaEl) { ipaEl.textContent = item.ipa || ''; ipaEl.style.textAlign = 'center'; ipaEl.style.marginTop = '6px'; }
      if (vnEl) { vnEl.textContent = item.prompt_vi || ''; vnEl.style.textAlign = 'center'; vnEl.style.marginTop = '6px'; }
      listeningIndex = idx;
      const total = (lessons[currentLessonIdx] && lessons[currentLessonIdx].sentence) ? lessons[currentLessonIdx].sentence.length : 0;
      const pageInfo = document.getElementById('pageInfo');
      if (pageInfo) pageInfo.textContent = `${listeningIndex - sessionStart + 1} / ${sessionEnd - sessionStart + 1} (t·ªïng ${total})`;
    }

    function playPreviewAt(idx, sequential) {
      if (currentLessonIdx === -1) return;
      const lesson = lessons[currentLessonIdx] || {};
      const data = lesson.sentence || [];
      if (!data[idx]) return;
      // stop any current playback
      try { if (currentHowl) { currentHowl.stop(); currentHowl.unload(); } } catch(e){}
      isPreviewPlaying = true;
      listeningIndex = idx;
      highlightListeningItem(idx);

      const text = data[idx].prompt || data[idx].answer || '';
      // temporarily override global pauseSeconds
      const prevPause = pauseSeconds;
      pauseSeconds = listeningPauseSeconds;
      playAudioFor(text, () => {
        // restore pause
        pauseSeconds = prevPause;
        // If auto-loop is enabled and we've reached the end, restart regardless of how playback was started
        if (idx === sessionEnd && listeningAutoLoop) {
          listeningIndex = sessionStart;
          updateListeningCard(listeningIndex);
          playPreviewAt(listeningIndex, true);
          return;
        }
        if (sequential) {
          if (idx < sessionEnd) {
            playPreviewAt(idx + 1, true);
          } else {
            isPreviewPlaying = false;
            // ensure UI reflects stopped state (update Play button if present)
            const playBtn = document.getElementById('lpPlay');
            if (playBtn) playBtn.textContent = '‚ñ∂ Ph√°t';
          }
        } else {
          isPreviewPlaying = false;
          const playBtn = document.getElementById('lpPlay');
          if (playBtn) playBtn.textContent = '‚ñ∂ Ph√°t';
        }
      });
    }

    function stopPreviewPlayback() {
      isPreviewPlaying = false;
      try { if (currentHowl) { currentHowl.stop(); currentHowl.unload(); } } catch(e){}
      try { if (ttsAudio) { ttsAudio.pause(); ttsAudio.currentTime = 0; ttsAudio = null; } } catch(e){}
      // restart recognition if needed
      if (recognition && (isSpeakingMode || isReadingModeActive)) {
        try { recognition.start(); setStatus('ƒêang nghe...', 'green'); } catch(e) { console.log('restart recognition failed', e); }
      } else {
        setStatus('Idle');
      }
    }

    function rewindPreview(seconds) {
      // Attempt to seek back `seconds` in current audio (Howl or TTS)
      try {
        if (currentHowl && typeof currentHowl.seek === 'function') {
          const pos = currentHowl.seek() || 0;
          const newPos = Math.max(0, pos - seconds);
          currentHowl.seek(newPos);
          return;
        }
      } catch (e) { console.log('Howl rewind failed', e); }
      try {
        if (ttsAudio && typeof ttsAudio.currentTime !== 'undefined') {
          ttsAudio.currentTime = Math.max(0, (ttsAudio.currentTime || 0) - seconds);
          return;
        }
      } catch (e) { console.log('TTS rewind failed', e); }
      // if no audio, as fallback, replay current sentence from start
      if (currentMode === 'listeningPreview') {
        playPreviewAt(listeningIndex, false);
      }
    }

    // global keyboard shortcuts for Listening Preview
    window.addEventListener('keydown', (ev) => {
      if (currentMode !== 'listeningPreview') return;
      if (ev.key === 'ArrowLeft') {
        ev.preventDefault(); if (listeningIndex > sessionStart) { playPreviewAt(listeningIndex - 1, false); }
      } else if (ev.key === 'ArrowRight') {
        ev.preventDefault(); if (listeningIndex < sessionEnd) { playPreviewAt(listeningIndex + 1, false); }
      } else if (ev.key === 'ArrowDown') {
        ev.preventDefault(); playPreviewAt(listeningIndex, false);
      } else if (ev.key === 'ArrowUp') {
        ev.preventDefault(); rewindPreview(rewindSeconds);
      } else if (ev.key.toLowerCase && ev.key.toLowerCase() === 'r') {
        ev.preventDefault(); // restart session from sessionStart
        listeningIndex = sessionStart;
        updateListeningCard(listeningIndex);
        playPreviewAt(listeningIndex, true);
        const pb = document.getElementById('lpPlay'); if (pb) pb.textContent = '‚è∏ D·ª´ng';
      }
    });

    function renderItem(item, idx, total) {
      if (!item) return;
      const div = document.createElement('div');
      div.className = 'exercise-item';
      const answer = item.answer_en || item.answer;
      const questionText = item.prompt_vi || item.prompt || '';
      const inputId = `input_${idx}`;

      div.innerHTML = `
        <div class="question">${idx + 1}. ${questionText}</div>
        <input type="text" id="${inputId}" placeholder="${isSpeakingMode ? 'üé§ ƒêang nghe... h√£y n√≥i' : 'Nh·∫≠p c√¢u tr·∫£ l·ªùi...'}" autocomplete="off">
        <div class="feedback" id="fb_${idx}"></div>
      `;
      exerciseArea.appendChild(div);

      const input = document.getElementById(inputId);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          clearTimeout(delayTimer);
          const textToSpeak = answer;
          playAudioFor(textToSpeak);

          const isCorrect = checkLogic(input.value, answer);
          const fb = document.getElementById(`fb_${idx}`);
          
          if (isCorrect) {
            const viTrans = item.prompt_vi || "";
            fb.className = 'feedback success';
            fb.innerHTML = `‚úÖ Ch√≠nh x√°c!${viTrans ? `<br><span class="translation-hint"> Nghƒ©a: ${viTrans}</span>` : ''}`;
            
            delayTimer = setTimeout(() => {
              if (isSingleMode) {
                // advance within the session range, not the full lesson
                if (currentExIdx < sessionEnd) {
                  currentExIdx++; render();
                } else {
                  // reached end of session
                  if (sentenceAutoLoop) {
                    currentExIdx = sessionStart; render();
                  } else {
                    setStatus('Ho√†n th√†nh phi√™n', 'var(--muted)');
                  }
                }
              } else {
                const nextInput = document.getElementById(`input_${idx + 1}`);
                if (nextInput) { nextInput.scrollIntoView({ behavior: 'smooth', block: 'center' }); nextInput.focus(); }
              }
            }, parseInt(delayRange.value));
          } else {
            fb.className = 'feedback error';
            fb.textContent = `‚ùå Ch∆∞a ƒë√∫ng! ƒê√°p √°n: ${answer}`;
          }
        }
      });
    }

    function checkLogic(userVal, correctVal) {
      return similarity(userVal, correctVal) >= matchThreshold;
    }

    function playAudioFor(text, onComplete) {
      if (!text) {
        if (typeof onComplete === 'function') onComplete();
        return;
      }
      const entry = resolveAudioEntry(text);
      if (entry && entry.file) {
        const path = ('LESSON/' + entry.file).replace(/\\/g, '/').replace(/\\/g, '/');
        try { if (currentHowl) { currentHowl.stop(); currentHowl.unload(); } } catch(e){}
        // if recognition is active and in speaking/reading mode, stop it temporarily to avoid self-detection
        if (recognition && (isSpeakingMode || isReadingModeActive)) {
          willRestartRecognition = true;
          try { recognition.stop(); } catch(e) { console.log('stop recognition failed', e); }
        }
        setStatus('ƒêang ph√°t...', 'var(--primary)');
        currentHowl = new Howl({ src: [path], html5: true, onend: function() {
          // after playback, show waiting period for user to read answer
          setStatus(`ƒêang ch·ªù ${pauseSeconds}s`, 'var(--accent)');
          setTimeout(() => {
            // call completion callback before restarting recognition so UI can update
            if (typeof onComplete === 'function') {
              try { onComplete(); } catch (e) { console.log('onComplete error', e); }
            }
            willRestartRecognition = false;
            if (recognition && (isSpeakingMode || isReadingModeActive)) {
              try { recognition.start(); setStatus('ƒêang nghe...', 'green'); } catch(e) { console.log('restart recognition failed', e); setStatus('L·ªói nghe', 'var(--error)'); }
            } else {
              setStatus('Idle');
            }
          }, pauseSeconds * 1000);
        }});
        currentHowl.play();
        return;
      }
      // fallback to TTS
      // stop recognition briefly for TTS playback as well
      if (recognition && (isSpeakingMode || isReadingModeActive)) {
        willRestartRecognition = true;
        try { recognition.stop(); } catch(e) { console.log('stop recognition failed', e); }
      }
      setStatus('ƒêang ph√°t...', 'var(--primary)');
      speak(text, () => {
        // after TTS finished, wait pauseSeconds before calling completion and resuming recognition
        setStatus(`ƒêang ch·ªù ${pauseSeconds}s`, 'var(--accent)');
        setTimeout(() => {
          if (typeof onComplete === 'function') {
            try { onComplete(); } catch (e) { console.log('onComplete error', e); }
          }
          willRestartRecognition = false;
          if (recognition && (isSpeakingMode || isReadingModeActive)) {
            try { recognition.start(); setStatus('ƒêang nghe...', 'green'); } catch(e) { console.log('restart recognition failed', e); setStatus('L·ªói nghe', 'var(--error)'); }
          } else {
            setStatus('Idle');
          }
        }, pauseSeconds * 1000);
      });
    }

    function getSelectedEngine() {
      const sel = document.getElementById('audioEngineSelect');
      if (!sel) return localStorage.getItem('preferred_tts_engine') || 'gTTS';
      return sel.value || (localStorage.getItem('preferred_tts_engine') || 'gTTS');
    }

    function resolveAudioEntry(text) {
      if (!text) return null;
      const trimmed = text.toString().trim();
      const preferred = getSelectedEngine();
      // prefer mapping that matches both text and engine
      let entry = audioMapping.find(it => it.text && it.text.toString().trim() === trimmed && it.engine === preferred);
      if (entry) return entry;
      // fallback: any entry that matches text regardless engine
      entry = audioMapping.find(it => it.text && it.text.toString().trim() === trimmed);
      return entry || null;
    }

    function speak(text, onEnded) {
      if (!text) {
        if (typeof onEnded === 'function') onEnded();
        return;
      }
      const url = `https://translate.google.com/translate_tts?ie=UTF-8&tl=en&client=tw-ob&q=${encodeURIComponent(text)}`;
      try {
        // create global ttsAudio so we can seek/rewind
        if (ttsAudio) {
          try { ttsAudio.pause(); } catch(e){}
          ttsAudio = null;
        }
        ttsAudio = new Audio(url);
        ttsAudio.crossOrigin = 'anonymous';
        ttsAudio.play().catch(e => console.log("Audio play blocked", e));
        ttsAudio.onended = function() { ttsAudio = null; if (typeof onEnded === 'function') onEnded(); };
      } catch (e) {
        console.log('TTS play error', e);
        ttsAudio = null;
        if (typeof onEnded === 'function') onEnded();
      }
    }

    document.getElementById('prevEx').addEventListener('click', () => { 
      if (currentExIdx > sessionStart) { 
        currentExIdx--; 
        if (currentMode === 'reading') renderReading(); else render(); 
      } 
    });
    document.getElementById('nextEx').addEventListener('click', () => { 
      const lesson = lessons[currentLessonIdx] || {};
      const data = lesson.sentence || [];
      const maxIdx = Math.min(sessionEnd, data.length - 1);
      if (currentExIdx < maxIdx) { 
        currentExIdx++; 
        if (currentMode === 'reading') renderReading(); else render(); 
      } 
    });
    // populate server lesson list on load
    loadLessonList();
  </script>
</body>
</html>