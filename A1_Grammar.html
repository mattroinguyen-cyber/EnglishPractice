<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>English Practice</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f4f7fc; --card-bg: #ffffff; --text: #2c3e50; --muted: #6b7c93;
      --primary: #2575fc; --accent: #6a11cb; --success: #2ecc71; --error: #e74c3c;
      --shadow: 0 8px 20px rgba(23, 43, 77, 0.12); --border: rgba(0,0,0,0.08);
    }
    [data-theme="dark"] {
      --bg: #0f172a; --card-bg: #111827; --text: #e5e7eb; --muted: #9ca3af;
      --shadow: 0 10px 24px rgba(0,0,0,0.35); --border: rgba(255,255,255,0.08);
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: 'Poppins', sans-serif; color: var(--text); background: var(--bg); min-height: 100vh; scroll-behavior: smooth; }
    .container { max-width: 1000px; margin: 40px auto; padding: 0 20px; }
    header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px; }
    .logo { width: 44px; height: 44px; background: linear-gradient(135deg, var(--accent), var(--primary)); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 1.2rem; }
    
    .control-panel { 
      display: flex; flex-wrap: wrap; gap: 15px; background: var(--card-bg); 
      padding: 15px; border-radius: 12px; box-shadow: var(--shadow); margin-bottom: 20px; align-items: center;
    }
    .option-group { display: flex; align-items: center; gap: 10px; font-weight: 600; font-size: 0.9rem; border-right: 1px solid var(--border); padding-right: 15px; }
    .option-group:last-child { border-right: none; }
    
    select { flex: 1; min-width: 180px; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--card-bg); color: var(--text); font-weight: 600; outline: none; }
    .btn { border: none; border-radius: 8px; padding: 10px 16px; font-weight: 600; cursor: pointer; transition: 0.2s; background: var(--primary); color: #fff; }
    .btn.ghost { background: transparent; border: 1px solid var(--border); color: var(--text); }
    .btn.active-mode { background: var(--success); color: white; }
    .btn.speaking-on { background: #ff9f43; color: white; box-shadow: 0 0 10px rgba(255,159,67,0.4); }
    
    .exercise-item { background: var(--card-bg); padding: 25px; border-radius: 12px; box-shadow: var(--shadow); margin-bottom: 20px; border: 1px solid var(--border); animation: fadeIn 0.4s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
    
    .question { font-size: 1.2rem; font-weight: 600; margin-bottom: 10px; color: var(--text); }
    .vietnamese { font-style: italic; color: var(--muted); border-left: 3px solid var(--primary); padding-left: 10px; margin-bottom: 15px; }
    .translation-hint { color: var(--primary); font-weight: 600; font-style: italic; display: block; margin-top: 8px; font-size: 0.95rem; }

    input[type="text"] { width: 100%; padding: 15px; border-radius: 8px; border: 2px solid var(--border); background: transparent; color: var(--text); font-size: 1.1rem; outline: none; transition: 0.3s; }
    input:focus { border-color: var(--primary); background: rgba(37, 117, 252, 0.02); }
    
    .feedback { margin-top: 15px; padding: 12px; border-radius: 8px; min-height: 20px; font-weight: 600; line-height: 1.5; }
    .feedback.success { color: var(--success); background: rgba(46, 204, 113, 0.1); }
    .feedback.error { color: var(--error); background: rgba(231, 76, 60, 0.1); }
    
    .tabs { display: flex; gap: 10px; margin-bottom: 20px; }
    .tab { padding: 10px 20px; border-radius: 8px; cursor: pointer; background: var(--card-bg); border: 1px solid var(--border); color: var(--text); font-weight: 600; transition: 0.2s; }
    .tab.active { background: var(--primary); color: white; border-color: var(--primary); }
    
    .pagination { display: flex; justify-content: center; align-items: center; gap: 20px; margin-top: 10px; padding-bottom: 40px; }
    
    #backToTop {
      position: fixed; bottom: 30px; right: 30px; width: 50px; height: 50px;
      background: var(--primary); color: white; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; box-shadow: var(--shadow); border: none;
      opacity: 0; visibility: hidden; transition: 0.3s; z-index: 1000; font-size: 1.2rem;
    }
    #backToTop.show { opacity: 1; visibility: visible; }
    .hide { display: none; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>
<body data-theme="light">
  <div class="container">
    <header>
      <div style="display:flex; align-items:center; gap:12px">
        <div class="logo">4S</div>
        <div>
          <h1 style="margin:0; font-size: 1.5rem;">A1 GRAMMA CORE</h1>
          <p style="margin:0; font-size: 0.8rem; color: var(--muted);">Listen - Speak - Read - Write</p>
        </div>
      </div>
      <div style="display:flex; gap:10px">
        <!-- Import JSON removed; lessons are loaded from json_list.json / LESSON/ -->
        <button class="btn ghost" id="themeToggle" title="Chuy·ªÉn giao di·ªán s√°ng/t·ªëi">üåô</button>
      </div>
    </header>

    <div class="control-panel">
      <div class="option-group" style="flex:1">
        <select id="lessonSelect"><option value="">-- Ch·ªçn b√†i h·ªçc --</option></select>
      </div>
      
      <div class="option-group">
        <span>Ngh·ªâ:</span>
        <input type="range" id="delayRange" min="0" max="5000" step="500" value="1000" title="Th·ªùi gian ch·ªù (ms) tr∆∞·ªõc khi chuy·ªÉn c√¢u sau khi ph√°t ƒë√°p √°n ‚Äî k√©o sang tr√°i ƒë·ªÉ nhanh h∆°n">
        <span id="delayVal">1.0s</span>
      </div>

      <div class="option-group">
        <span>ƒê·ªçc ƒë√°p √°n:</span>
        <select id="pauseSelect" style="padding:8px; border-radius:6px;" title="Th·ªùi gian (gi√¢y) ƒë·ªÉ ng∆∞·ªùi h·ªçc nghe/nh·∫Øc l·∫°i sau khi ƒë√°p √°n ƒë∆∞·ª£c ph√°t">
          <option value="0" selected>0s</option>
          <option value="1">1s</option>
          <option value="2">2s</option>
          <option value="3">3s</option>
          <option value="4">4s</option>
          <option value="5">5s</option>
        </select>
        <span id="statusLabel" style="margin-left:12px; font-weight:700; color:var(--muted);">Tr·∫°ng th√°i: Idle</span>
      </div>

      <div class="option-group">
        <span>T·ª∑ l·ªá ƒë√∫ng:</span>
        <input type="range" id="thresholdRange" min="50" max="100" step="1" value="100" title="T·ª∑ l·ªá t∆∞∆°ng ƒë·ªìng t·ªëi thi·ªÉu ƒë·ªÉ coi l√† ƒë√∫ng (50% - d·ªÖ, 100% - ch√≠nh x√°c)">
        <span id="thresholdVal" style="margin-left:8px; font-weight:700;">100%</span>
        <span title="N·∫øu t·ª∑ l·ªá gi·ªëng (similarity) c·ªßa ph√°t √¢m so v·ªõi ƒë√°p √°n l·ªõn h∆°n ho·∫∑c b·∫±ng gi√° tr·ªã n√†y th√¨ s·∫Ω ƒë∆∞·ª£c ch·∫•m l√† ƒë√∫ng" style="margin-left:8px; color:var(--muted);">‚ÑπÔ∏è</span>
      </div>

      <div class="option-group">
        <button class="btn ghost" id="toggleSkillMode" title="B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô luy·ªán n√≥i">üéôÔ∏è Luy·ªán N√≥i</button>
        <button class="btn ghost" id="toggleViewMode" title="Chuy·ªÉn ch·∫ø ƒë·ªô hi·ªÉn th·ªã (C√¢u ƒë∆°n / T·∫•t c·∫£)">Ch·∫ø ƒë·ªô: T·∫•t c·∫£</button>
      </div>
      <div class="option-group">
        <span>Phi√™n:</span>
        <input type="number" id="sessionStartInput" min="1" value="1" style="width:70px; padding:6px; border-radius:6px;">
        <span> ƒë·∫øn </span>
        <input type="number" id="sessionEndInput" min="1" value="10" style="width:70px; padding:6px; border-radius:6px;">
        <button class="btn ghost" id="applySessionBtn" title="√Åp d·ª•ng ph·∫°m vi c√¢u cho phi√™n h·ªçc" style="margin-left:8px">√Åp d·ª•ng</button>
        <button class="btn ghost" id="bookmarkBtn" title="Bookmark v·ªã tr√≠ hi·ªán t·∫°i" style="margin-left:8px">üîñ L∆∞u</button>
        <button class="btn ghost" id="loadBookmarkBtn" title="T·∫£i bookmark" style="margin-left:6px">üìÇ T·∫£i</button>
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" id="tabReading" title="Ch·∫ø ƒë·ªô: B√†i ƒë·ªçc (Reading Test)">Reading Test</button>
      <button class="tab" id="tabSentence" title="Ch·∫ø ƒë·ªô: Vi·∫øt c√¢u (Sentence Writing)">Sentence writing</button>
    </div>

    <div id="exerciseArea"></div>

    <div id="pagination" class="pagination hide">
      <button class="btn ghost" id="prevEx" title="C√¢u tr∆∞·ªõc">‚óÄ C√¢u tr∆∞·ªõc</button>
      <span id="pageInfo" style="font-weight: 600;">1 / 1</span>
      <button class="btn ghost" id="nextEx" title="C√¢u sau">C√¢u sau ‚ñ∂</button>
    </div>
  </div>

  <button id="backToTop" title="L√™n ƒë·∫ßu trang">‚ñ≤</button>

  <script>
    let lessons = [];
    let currentLessonIdx = -1;
    let currentExIdx = 0;
    let isSingleMode = false;
    let isSpeakingMode = false; // d√πng cho luy·ªán n√≥i th·ª±c s·ª±
    // currentMode controls UI: 'sentence' or 'reading'
    let currentMode = 'reading'; // default to Reading Test
    let isReadingModeActive = false;
    let delayTimer = null;

    let recognition = null;
    let isRecognitionSupported = false;
    let willRestartRecognition = false;
    let pauseSeconds = 0; // seconds user can read answer (default 0s for immediate resume)
    let matchThreshold = 1.0; // similarity threshold (0..1), default 100% exact match
    // session controls: show only a range of sentences per study session
    let sessionStart = 0; // 0-based index
    let sessionEnd = 9;   // inclusive 0-based index; default show 1..10
    let sessionSize = 10;

    // Server lesson metadata and audio mapping
    let lessonsMeta = [];
    let audioMapping = [];
    let currentHowl = null;

    // Load json_list.json to populate server lessons
    function loadLessonList() {
      fetch('json_list.json')
        .then(res => res.json())
        .then(data => {
          lessonsMeta = data.lessons || [];
          // remove previously appended remote options to avoid duplicates
          [...lessonSelect.querySelectorAll('option')].filter(o => o.value && o.value.startsWith('remote:')).forEach(o => o.remove());
          // append server lessons to lessonSelect
          lessonsMeta.forEach((m, i) => {
            const opt = document.createElement('option');
            opt.value = 'remote:' + i;
            opt.textContent = (m.name || '').replace('.json','');
            lessonSelect.appendChild(opt);
          });
        })
        .catch(err => console.log('Kh√¥ng th·ªÉ ƒë·ªçc json_list.json', err));
    }

    // Load a lesson JSON + mapping from LESSON/ folder
    function loadRemoteLesson(idx) {
      const meta = lessonsMeta[idx];
      if (!meta) return;
      fetch('LESSON/' + meta.name)
        .then(r => r.json())
        .then(data => {
          // convert array-of-arrays format into expected lesson object
          const lessonObj = { title: meta.name, fill: [], sentence: [] };
          if (Array.isArray(data)) {
            data.forEach((row, ridx) => {
              // row expected: [term, ipa, vi, example, example_ipa, example_vi]
                const front = (row[0] || '').toString().trim();
                const frontVi = row[2] || '';
                const back = (row[3] || '').toString().trim();
                const backVi = row[5] || '';
                lessonObj.fill.push({ id: ridx, question: front, answer: front, hint_vi: frontVi });
                // If both front (question) and back (answer) exist and differ, create two practice items:
                // 1) practice the question line (user reads the question)
                // 2) practice the answer line (user reads the answer)
                if (front && back && front !== back) {
                  lessonObj.sentence.push({ id: ridx*2, prompt: front, answer: front, prompt_vi: frontVi });
                  lessonObj.sentence.push({ id: ridx*2 + 1, prompt: back, answer: back, prompt_vi: backVi });
                } else {
                  // single-sentence format: use whichever text is present
                  const text = back || front || '';
                  lessonObj.sentence.push({ id: ridx, prompt: text, answer: text, prompt_vi: backVi || frontVi });
                }
            });
          } else {
            // if lesson is already in object format, try to use its fill/sentence
            lessonObj.fill = data.fill || data.items || [];
            lessonObj.sentence = data.sentence || [];
          }

          // load mapping
          if (meta.mapping) {
            fetch('LESSON/' + meta.mapping)
              .then(r => r.json())
              .then(map => {
                audioMapping = map || [];
              })
              .catch(e => { console.log('Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c mapping:', e); audioMapping = []; });
          } else {
            audioMapping = [];
          }

          // replace lessons with this remote lesson for convenience
          lessons = [lessonObj];
          currentLessonIdx = 0;
          currentExIdx = 0;
          render();
        })
        .catch(err => console.error('L·ªói khi t·∫£i b√†i h·ªçc:', err));
    }

    const lessonSelect = document.getElementById('lessonSelect');
    const exerciseArea = document.getElementById('exerciseArea');
    const delayRange = document.getElementById('delayRange');
    const skillBtn = document.getElementById('toggleSkillMode');

    delayRange.addEventListener('input', (e) => {
      document.getElementById('delayVal').textContent = (e.target.value / 1000).toFixed(1) + 's';
    });

    // thresholdRange controls fuzzy matching tolerance for correctness (50% - 100%)
    document.getElementById('thresholdRange').addEventListener('input', (e) => {
      const val = parseInt(e.target.value, 10) || 100;
      document.getElementById('thresholdVal').textContent = val + '%';
      matchThreshold = val / 100;
    });

    // pauseSelect controls how long to show answer after playback (1-5s)
    document.getElementById('pauseSelect').addEventListener('change', (e) => {
      pauseSeconds = parseInt(e.target.value, 10) || 2;
    });

    // session apply / bookmark handlers
    document.getElementById('applySessionBtn').addEventListener('click', () => {
      const lesson = lessons[currentLessonIdx] || {};
      const total = (lesson.sentence || []).length || 0;
      let s = parseInt(document.getElementById('sessionStartInput').value, 10) || 1;
      let e = parseInt(document.getElementById('sessionEndInput').value, 10) || Math.min(s + sessionSize - 1, total);
      s = Math.max(1, Math.min(s, total));
      e = Math.max(s, Math.min(e, total));
      sessionStart = s - 1;
      sessionEnd = e - 1;
      sessionSize = sessionEnd - sessionStart + 1;
      currentExIdx = sessionStart;
      setStatus(`Phi√™n: ${s} - ${e}`, 'var(--muted)');
      if (currentMode === 'reading') renderReading(); else render();
    });

    document.getElementById('bookmarkBtn').addEventListener('click', () => {
      if (currentLessonIdx === -1) return setStatus('Kh√¥ng c√≥ b√†i ƒë·ªÉ bookmark', 'var(--error)');
      const lesson = lessons[currentLessonIdx];
      const key = `bookmark_${lesson.title || 'lesson'}`;
      const payload = { sessionStart: sessionStart, current: currentExIdx };
      try { localStorage.setItem(key, JSON.stringify(payload)); setStatus('ƒê√£ l∆∞u bookmark', 'green'); } catch (e) { setStatus('L∆∞u bookmark th·∫•t b·∫°i', 'var(--error)'); }
    });

    document.getElementById('loadBookmarkBtn').addEventListener('click', () => {
      if (currentLessonIdx === -1) return setStatus('Kh√¥ng c√≥ b√†i ƒë·ªÉ t·∫£i bookmark', 'var(--error)');
      const lesson = lessons[currentLessonIdx];
      const key = `bookmark_${lesson.title || 'lesson'}`;
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return setStatus('Kh√¥ng t√¨m th·∫•y bookmark', 'var(--muted)');
        const obj = JSON.parse(raw);
        sessionStart = obj.sessionStart || 0;
        currentExIdx = obj.current || sessionStart;
        sessionEnd = Math.min(sessionStart + sessionSize - 1, (lesson.sentence || []).length - 1);
        // update inputs (1-based)
        document.getElementById('sessionStartInput').value = sessionStart + 1;
        document.getElementById('sessionEndInput').value = sessionEnd + 1;
        setStatus('ƒê√£ t·∫£i bookmark', 'green');
        if (currentMode === 'reading') renderReading(); else render();
      } catch (e) { setStatus('T·∫£i bookmark l·ªói', 'var(--error)'); }
    });

    function setStatus(text, color) {
      const el = document.getElementById('statusLabel');
      if (!el) return;
      el.textContent = 'Tr·∫°ng th√°i: ' + text;
      el.style.color = color || 'var(--muted)';
    }

    function initSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        alert("Tr√¨nh duy·ªát n√†y kh√¥ng h·ªó tr·ª£ luy·ªán n√≥i (Speech Recognition). Vui l√≤ng d√πng Google Chrome.");
        isRecognitionSupported = false;
        return;
      }
      isRecognitionSupported = true;
      recognition = new SpeechRecognition();
      recognition.lang = "en-US";
      recognition.continuous = false;
      recognition.interimResults = false;

      recognition.onresult = (event) => {
        const text = event.results[0][0].transcript;
        if (currentMode === 'reading' && isReadingModeActive) {
          handleReadingResult(text);
        } else {
          handleSpeechResult(text);
        }
      };

      recognition.onend = () => {
        if (isSpeakingMode || isReadingModeActive) {
          // n·∫øu ƒëang t·∫°m d·ª´ng v√¨ playback th√¨ kh√¥ng restart ·ªü ƒë√¢y
          if (willRestartRecognition) return;
          try {
            recognition.start();
          } catch (e) {
            console.log("Cannot restart recognition immediately:", e);
          }
        }
      };

      recognition.onerror = (event) => {
        console.log("Speech recognition error:", event.error);
      };
    }

    function cleanSpeech(str) {
      return str
        .toLowerCase()
        .replace(/\./g, "")              // b·ªè d·∫•u ch·∫•m
        .replace(/:/g, "")               // b·ªè d·∫•u :
        .replace(/a\s*m/g, "am")         // chu·∫©n h√≥a am
        .replace(/p\s*m/g, "pm")         // chu·∫©n h√≥a pm
        .replace(/(\d+)00/g, "$1")       // 7:00 ‚Üí 7
        .replace(/everyday/g, "every day") // s·ª≠a everyday ‚Üí every day
        .replace(/[^\w\s]/g, "")         // b·ªè k√Ω t·ª± ƒë·∫∑c bi·ªát
        .replace(/\s+/g, " ")            // chu·∫©n h√≥a kho·∫£ng tr·∫Øng
        .trim();
    }

    // Levenshtein distance for fuzzy matching
    function levenshtein(a, b) {
      const an = a ? a.length : 0;
      const bn = b ? b.length : 0;
      if (an === 0) return bn;
      if (bn === 0) return an;
      const matrix = Array.from({ length: bn + 1 }, (_, i) => new Array(an + 1));
      for (let i = 0; i <= bn; i++) matrix[i][0] = i;
      for (let j = 0; j <= an; j++) matrix[0][j] = j;
      for (let i = 1; i <= bn; i++) {
        for (let j = 1; j <= an; j++) {
          const cost = a[j - 1] === b[i - 1] ? 0 : 1;
          matrix[i][j] = Math.min(
            matrix[i - 1][j] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j - 1] + cost
          );
        }
      }
      return matrix[bn][an];
    }

    function similarity(a, b) {
      const s1 = cleanSpeech((a || '').toString());
      const s2 = cleanSpeech((b || '').toString());
      if (!s1 && !s2) return 1;
      const dist = levenshtein(s1, s2);
      const max = Math.max(s1.length, s2.length);
      return max === 0 ? 1 : Math.max(0, 1 - dist / max);
    }

    function startSpeechMode() {
      if (!recognition) {
        initSpeechRecognition();
      }
      if (!isRecognitionSupported) return;
      isSpeakingMode = true;
      // √©p v·ªÅ ch·∫ø ƒë·ªô c√¢u ƒë∆°n ƒë·ªÉ luy·ªán n√≥i theo t·ª´ng c√¢u
      if (!isSingleMode) {
        isSingleMode = true;
        const viewBtn = document.getElementById('toggleViewMode');
        viewBtn.textContent = 'Ch·∫ø ƒë·ªô: C√¢u ƒë∆°n';
        viewBtn.classList.add('active-mode');
      }
      currentExIdx = 0;
      render();
      try {
        recognition.start();
      } catch (e) {
        console.log("Recognition already started:", e);
      }
    }

    function stopSpeechMode() {
      isSpeakingMode = false;
      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.log("Error stopping recognition:", e);
        }
      }
      render();
    }

    function handleSpeechResult(text) {
      if (currentLessonIdx === -1) return;
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const item = data[currentExIdx];
      if (!item) return;

      const answer = item.answer_en || item.answer;
      const fb = document.getElementById(`fb_${currentExIdx}`);
      if (!fb) return;

      const clean = (str) => str.toLowerCase()
        .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()?"']/g,"")
        .replace(/\s{2,}/g," ")
        .trim();

      if (similarity(text, answer) >= matchThreshold) {
        const viTrans = item.prompt_vi || "";

        fb.className = 'feedback success';
        fb.innerHTML = `‚úÖ Ch√≠nh x√°c!${viTrans ? `<br><span class="translation-hint"> Nghƒ©a: ${viTrans}</span>` : ''}`;

        const textToSpeak = answer;
        playAudioFor(textToSpeak);

        clearTimeout(delayTimer);
        delayTimer = setTimeout(() => {
          if (currentExIdx < data.length - 1) {
            currentExIdx++;
            render();
          }
        }, parseInt(delayRange.value));
      } else {
        fb.className = 'feedback error';
        fb.innerHTML = `‚ùå B·∫°n n√≥i: "<span>${text}</span>"<br>ƒê√°p √°n ƒë√∫ng: ${answer}`;
        // ph√°t ƒë√°p √°n ƒë·ªÉ ng∆∞·ªùi h·ªçc c√≥ th·ªÉ nghe v√† nh·∫Øc l·∫°i
        playAudioFor(answer);
      }
    }

    function handleReadingResult(text) {
      if (currentLessonIdx === -1) return;
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const item = data[currentExIdx];
      if (!item) return;

      const expected = item.answer || item.prompt || '';
      const fb = document.getElementById('fb_reading');
      if (!fb) return;

      if (similarity(text, expected) >= matchThreshold) {
        fb.className = 'feedback success';
        fb.innerHTML = `‚úÖ Ch√≠nh x√°c!`;
        // play back correct answer then move to next
        playAudioFor(expected, () => {
          // advance to next sentence
          if (currentExIdx < data.length - 1) {
            currentExIdx++;
            renderReading();
          } else {
            // finished
            isReadingModeActive = false;
            setStatus('Ho√†n th√†nh', 'var(--success)');
            renderReading();
          }
        });
      } else {
        fb.className = 'feedback error';
        fb.innerHTML = `‚ùå B·∫°n n√≥i: "<span>${text}</span>"`;
        // play correct answer for user to repeat
        playAudioFor(expected);
      }
    }

    skillBtn.addEventListener('click', () => {
      if (!isSpeakingMode) {
        skillBtn.textContent = 'üõë D·ª´ng Luy·ªán N√≥i';
        skillBtn.classList.add('speaking-on');
        startSpeechMode();
      } else {
        skillBtn.textContent = 'üéôÔ∏è Luy·ªán N√≥i';
        skillBtn.classList.remove('speaking-on');
        stopSpeechMode();
      }
    });

    document.getElementById('themeToggle').addEventListener('click', () => {
      const isLight = document.body.getAttribute('data-theme') === 'light';
      document.body.setAttribute('data-theme', isLight ? 'dark' : 'light');
    });

    window.addEventListener('scroll', () => {
      document.getElementById('backToTop').classList.toggle('show', window.scrollY > 200);
    });
    document.getElementById('backToTop').addEventListener('click', () => window.scrollTo({top: 0}));

    // load server lessons list on startup
    loadLessonList();

    // Tab handlers for switching modes
    document.getElementById('tabSentence').addEventListener('click', () => {
      currentMode = 'sentence';
      document.getElementById('tabSentence').classList.add('active');
      document.getElementById('tabReading').classList.remove('active');
      isReadingModeActive = false;
      render();
    });

    document.getElementById('tabReading').addEventListener('click', () => {
      currentMode = 'reading';
      document.getElementById('tabReading').classList.add('active');
      document.getElementById('tabSentence').classList.remove('active');
      renderReading();
    });

    lessonSelect.addEventListener('change', (e) => { 
      const v = e.target.value;
      if (!v) return;
      if (v.startsWith('remote:')) {
        const idx = parseInt(v.split(':')[1], 10);
        loadRemoteLesson(idx);
        return;
      }
      // local imported lessons (legacy behaviour)
      if (!isNaN(parseInt(v))) {
        currentLessonIdx = parseInt(v);
        currentExIdx = 0;
        render();
      }
    });
    
    document.getElementById('toggleViewMode').addEventListener('click', (e) => {
      isSingleMode = !isSingleMode;
      e.target.textContent = isSingleMode ? 'Ch·∫ø ƒë·ªô: C√¢u ƒë∆°n' : 'Ch·∫ø ƒë·ªô: T·∫•t c·∫£';
      e.target.classList.toggle('active-mode', isSingleMode);
      currentExIdx = 0; 
      render();
    });

    // tabs removed: only Sentence writing supported

    function render() {
      // if we're in reading mode, prefer the reading renderer
      if (currentMode === 'reading') {
        renderReading();
        return;
      }
      exerciseArea.innerHTML = '';
      if (currentLessonIdx === -1) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Vui l√≤ng ch·ªçn b√†i h·ªçc ƒë·ªÉ b·∫Øt ƒë·∫ßu.</div>';
        document.getElementById('pagination').classList.add('hide');
        return;
      }
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const total = data.length;
      // clamp session range
      sessionStart = Math.max(0, Math.min(sessionStart, Math.max(0, total - 1)));
      sessionEnd = Math.max(sessionStart, Math.min(sessionEnd, total - 1));

      if (isSingleMode) {
        document.getElementById('pagination').classList.remove('hide');
        renderItem(data[currentExIdx], currentExIdx, total);
        const visibleCount = sessionEnd - sessionStart + 1;
        document.getElementById('pageInfo').textContent = `${currentExIdx - sessionStart + 1} / ${visibleCount} (t·ªïng ${total})`;
      } else {
        document.getElementById('pagination').classList.add('hide');
        // render only items in the session range
        for (let i = sessionStart; i <= sessionEnd; i++) {
          renderItem(data[i], i, total);
        }
      }
      
      const firstInput = exerciseArea.querySelector('input');
      if (firstInput) {
        if (isSpeakingMode) {
          firstInput.placeholder = 'üé§ ƒêang nghe... h√£y n√≥i';
        } else {
          firstInput.placeholder = 'Nh·∫≠p c√¢u tr·∫£ l·ªùi...';
        }
        firstInput.focus();
      }
    }

    function renderReading() {
      exerciseArea.innerHTML = '';
      if (currentLessonIdx === -1) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Vui l√≤ng Import ho·∫∑c ch·ªçn b√†i h·ªçc ƒë·ªÉ b·∫Øt ƒë·∫ßu Reading Test.</div>';
        document.getElementById('pagination').classList.add('hide');
        return;
      }
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const total = data.length;
      // clamp session range
      sessionStart = Math.max(0, Math.min(sessionStart, Math.max(0, total - 1)));
      sessionEnd = Math.max(sessionStart, Math.min(sessionEnd, total - 1));
      // ensure currentExIdx is within session
      currentExIdx = Math.max(sessionStart, Math.min(currentExIdx, sessionEnd));
      if (data.length === 0) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Kh√¥ng c√≥ c√¢u ƒë·ªÉ luy·ªán ƒë·ªçc trong b√†i h·ªçc n√†y.</div>';
        return;
      }
      document.getElementById('pagination').classList.remove('hide');
      const item = data[currentExIdx];
      const card = document.createElement('div');
      card.className = 'exercise-item';
      card.innerHTML = `
        <div style="font-size:1.6rem; font-weight:700; text-align:center; margin-bottom:16px;">${currentExIdx+1}. ${item.prompt || item.answer}</div>
        ${item.prompt_vi ? `<div class="vietnamese" style="text-align:center; opacity:0.75; font-size:0.95rem; margin-bottom:8px;">${item.prompt_vi}</div>` : ''}
        <div class="feedback" id="fb_reading"></div>
        <div style="text-align:center; margin-top:16px">
          <button class="btn ghost" id="readingToggle" title="B·∫Øt ƒë·∫ßu / D·ª´ng Reading Test">B·∫Øt ƒë·∫ßu Reading Test</button>
        </div>
      `;
      exerciseArea.appendChild(card);

      const toggle = document.getElementById('readingToggle');
      toggle.addEventListener('click', () => {
        if (!isReadingModeActive) {
          // start reading
          if (!recognition) initSpeechRecognition();
          isReadingModeActive = true;
          setStatus('ƒêang nghe...', 'green');
          try { recognition.start(); } catch(e) { console.log('start recognition failed', e); }
          toggle.textContent = 'D·ª´ng Reading Test';
        } else {
          // stop reading
          isReadingModeActive = false;
          try { recognition.stop(); } catch(e) { console.log('stop recognition failed', e); }
          setStatus('Idle');
          toggle.textContent = 'B·∫Øt ƒë·∫ßu Reading Test';
        }
      });
      const visibleCount = sessionEnd - sessionStart + 1;
      document.getElementById('pageInfo').textContent = `${currentExIdx - sessionStart + 1} / ${visibleCount} (t·ªïng ${total})`;
    }

    function renderItem(item, idx, total) {
      if (!item) return;
      const div = document.createElement('div');
      div.className = 'exercise-item';
      const answer = item.answer_en || item.answer;
      const questionText = item.prompt_vi || item.prompt || '';
      const inputId = `input_${idx}`;

      div.innerHTML = `
        <div class="question">${idx + 1}. ${questionText}</div>
        <input type="text" id="${inputId}" placeholder="${isSpeakingMode ? 'üé§ ƒêang nghe... h√£y n√≥i' : 'Nh·∫≠p c√¢u tr·∫£ l·ªùi...'}" autocomplete="off">
        <div class="feedback" id="fb_${idx}"></div>
      `;
      exerciseArea.appendChild(div);

      const input = document.getElementById(inputId);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          clearTimeout(delayTimer);
          const textToSpeak = answer;
          playAudioFor(textToSpeak);

          const isCorrect = checkLogic(input.value, answer);
          const fb = document.getElementById(`fb_${idx}`);
          
          if (isCorrect) {
            const viTrans = item.prompt_vi || "";
            fb.className = 'feedback success';
            fb.innerHTML = `‚úÖ Ch√≠nh x√°c!${viTrans ? `<br><span class="translation-hint"> Nghƒ©a: ${viTrans}</span>` : ''}`;
            
            delayTimer = setTimeout(() => {
              if (isSingleMode) {
                if (currentExIdx < total - 1) { currentExIdx++; render(); }
              } else {
                const nextInput = document.getElementById(`input_${idx + 1}`);
                if (nextInput) { nextInput.scrollIntoView({ behavior: 'smooth', block: 'center' }); nextInput.focus(); }
              }
            }, parseInt(delayRange.value));
          } else {
            fb.className = 'feedback error';
            fb.textContent = `‚ùå Ch∆∞a ƒë√∫ng! ƒê√°p √°n: ${answer}`;
          }
        }
      });
    }

    function checkLogic(userVal, correctVal) {
      return similarity(userVal, correctVal) >= matchThreshold;
    }

    function playAudioFor(text, onComplete) {
      if (!text) {
        if (typeof onComplete === 'function') onComplete();
        return;
      }
      const entry = audioMapping.find(it => it.text && it.text.toString().trim() === text.toString().trim());
      if (entry && entry.file) {
        const path = ('LESSON/' + entry.file).replace(/\\/g, '/').replace(/\\/g, '/');
        try { if (currentHowl) { currentHowl.stop(); currentHowl.unload(); } } catch(e){}
        // if recognition is active and in speaking/reading mode, stop it temporarily to avoid self-detection
        if (recognition && (isSpeakingMode || isReadingModeActive)) {
          willRestartRecognition = true;
          try { recognition.stop(); } catch(e) { console.log('stop recognition failed', e); }
        }
        setStatus('ƒêang ph√°t...', 'var(--primary)');
        currentHowl = new Howl({ src: [path], html5: true, onend: function() {
          // after playback, show waiting period for user to read answer
          setStatus(`ƒêang ch·ªù ${pauseSeconds}s`, 'var(--accent)');
          setTimeout(() => {
            // call completion callback before restarting recognition so UI can update
            if (typeof onComplete === 'function') {
              try { onComplete(); } catch (e) { console.log('onComplete error', e); }
            }
            willRestartRecognition = false;
            if (recognition && (isSpeakingMode || isReadingModeActive)) {
              try { recognition.start(); setStatus('ƒêang nghe...', 'green'); } catch(e) { console.log('restart recognition failed', e); setStatus('L·ªói nghe', 'var(--error)'); }
            } else {
              setStatus('Idle');
            }
          }, pauseSeconds * 1000);
        }});
        currentHowl.play();
        return;
      }
      // fallback to TTS
      // stop recognition briefly for TTS playback as well
      if (recognition && (isSpeakingMode || isReadingModeActive)) {
        willRestartRecognition = true;
        try { recognition.stop(); } catch(e) { console.log('stop recognition failed', e); }
      }
      setStatus('ƒêang ph√°t...', 'var(--primary)');
      speak(text, () => {
        // after TTS finished, wait pauseSeconds before calling completion and resuming recognition
        setStatus(`ƒêang ch·ªù ${pauseSeconds}s`, 'var(--accent)');
        setTimeout(() => {
          if (typeof onComplete === 'function') {
            try { onComplete(); } catch (e) { console.log('onComplete error', e); }
          }
          willRestartRecognition = false;
          if (recognition && (isSpeakingMode || isReadingModeActive)) {
            try { recognition.start(); setStatus('ƒêang nghe...', 'green'); } catch(e) { console.log('restart recognition failed', e); setStatus('L·ªói nghe', 'var(--error)'); }
          } else {
            setStatus('Idle');
          }
        }, pauseSeconds * 1000);
      });
    }

    function speak(text, onEnded) {
      if (!text) {
        if (typeof onEnded === 'function') onEnded();
        return;
      }
      const url = `https://translate.google.com/translate_tts?ie=UTF-8&tl=en&client=tw-ob&q=${encodeURIComponent(text)}`;
      try {
        const a = new Audio(url);
        a.crossOrigin = 'anonymous';
        a.play().catch(e => console.log("Audio play blocked", e));
        a.onended = function() { if (typeof onEnded === 'function') onEnded(); };
      } catch (e) {
        console.log('TTS play error', e);
        if (typeof onEnded === 'function') onEnded();
      }
    }

    document.getElementById('prevEx').addEventListener('click', () => { 
      if (currentExIdx > sessionStart) { 
        currentExIdx--; 
        if (currentMode === 'reading') renderReading(); else render(); 
      } 
    });
    document.getElementById('nextEx').addEventListener('click', () => { 
      const lesson = lessons[currentLessonIdx] || {};
      const data = lesson.sentence || [];
      const maxIdx = Math.min(sessionEnd, data.length - 1);
      if (currentExIdx < maxIdx) { 
        currentExIdx++; 
        if (currentMode === 'reading') renderReading(); else render(); 
      } 
    });
    // populate server lesson list on load
    loadLessonList();
  </script>
</body>
</html>