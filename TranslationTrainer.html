<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Translation Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    /* VS Code Dark+ inspired palette */
    :root {
      --page-bg-color: #1e1e1e;
      --bg: linear-gradient(180deg,#1e1e1e 0%, #181818 100%);
      --card-bg: #252526;
      --text: #d4d4d4;
      --muted: #9a9a9a;
      --primary: #569cd6; /* VSCode blue */
      --accent: #c586c0;  /* VSCode purple */
      --success: #6a9955;
      --error: #f44747;
      --glass: rgba(255,255,255,0.02);
      --shadow: 0 10px 26px rgba(0,0,0,0.6);
      --soft-shadow: 0 6px 14px rgba(0,0,0,0.5);
      --border: rgba(255,255,255,0.02);
      --radius: 12px;
    }
    [data-theme="light"] {
      --page-bg-color: #f4f7fc;
      --bg: linear-gradient(180deg,#f6f9ff 0%, #eef6ff 100%);
      --card-bg: rgba(255,255,255,0.98);
      --text: #0f1724;
      --muted: #51637a;
      --primary: #2563eb;
      --accent: #7c3aed;
      --shadow: 0 12px 30px rgba(20,35,80,0.08);
      --soft-shadow: 0 6px 18px rgba(20,35,80,0.04);
      --border: rgba(16,24,40,0.06);
      --radius: 12px;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: 'Noto Sans', 'Poppins', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; color: var(--text); background: var(--bg); min-height: 100vh; scroll-behavior: smooth; }
    .container { max-width: 1100px; margin: 36px auto; padding: 20px; }
    header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px; }
    .logo { width: 52px; height: 52px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: #071022; font-weight: 800; font-size: 1.1rem; box-shadow: var(--soft-shadow); }
    
    .control-panel { 
      display: flex; flex-wrap: wrap; gap: 8px; background: var(--card-bg);
      padding: 6px 8px; border-radius: calc(var(--radius) - 4px); box-shadow: var(--soft-shadow); margin-bottom: 12px; align-items: center; border: 1px solid rgba(255,255,255,0.03);
      font-size: 0.88rem; line-height: 1; 
      position: -webkit-sticky; position: sticky; top: 20px; z-index: 55;
    }
    .option-group { display: flex; align-items: center; gap: 8px; font-weight: 600; font-size: 0.86rem; border-right: 1px solid var(--border); padding-right: 8px; }
    .option-group:last-child { border-right: none; }
    
    select { flex: 1; min-width: 180px; padding: 10px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.03); background: var(--card-bg); color: var(--text); font-weight: 600; outline: none; box-shadow: none; }
    .btn { border: none; border-radius: 8px; padding: 10px 16px; font-weight: 700; cursor: pointer; transition: all 0.12s ease; background: linear-gradient(90deg,var(--primary),#4fc3f7); color: #0b1220; box-shadow: 0 6px 18px rgba(0,0,0,0.6); }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 10px 26px rgba(0,0,0,0.6); }
    .btn.ghost { background: transparent; border: 1px solid rgba(255,255,255,0.04); color: var(--primary); box-shadow: none; font-weight:700; }
    .btn.active-mode { background: linear-gradient(90deg,var(--success),#12c07a); color: white; }
    .btn.speaking-on { background: linear-gradient(90deg,#ff7a00,#ffb86b); color: white; box-shadow: 0 8px 28px rgba(255,124,0,0.18); }
    
    .exercise-item { background: var(--card-bg); padding: 26px; border-radius: var(--radius); box-shadow: var(--shadow); margin-bottom: 20px; border: 1px solid var(--border); animation: fadeIn 0.36s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
    
    .question { font-size: 1.18rem; font-weight: 700; margin-bottom: 10px; color: #2563EB; letter-spacing: 0.2px; }
    .vietnamese { font-style: italic; color: #12C07A; margin-bottom: 15px; font-family: 'Noto Sans', 'Poppins', sans-serif; }
    .translation-hint { color: #C586C0; font-weight: 600; font-style: italic; display: block; margin-top: 8px; font-size: 0.95rem; font-family: 'Noto Sans', 'Poppins', sans-serif; }
    
    .title { color: #2563EB; font-weight: 800; font-size: 2rem; line-height: 1.05; }
    .ipa { color: #C586C0; font-style: normal; font-size: 1.1rem; display: block; margin-top: 6px; }
    .vn { color: #12C07A; font-style: italic; font-size: 1rem; display: block; margin-top: 6px; font-family: 'Noto Sans', 'Poppins', sans-serif; }
    input[type="text"] { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.03); background: var(--card-bg); color: var(--text); font-size: 1.02rem; outline: none; transition: 0.18s; box-shadow: none; }
    input:focus { border-color: var(--primary); background: var(--card-bg); transform: translateY(-1px); }
    
    .feedback { margin-top: 15px; padding: 12px; border-radius: 8px; min-height: 20px; font-weight: 600; line-height: 1.5; }
    .feedback.success { color: var(--success); background: rgba(46, 204, 113, 0.1); }
    .feedback.error { color: var(--error); background: rgba(231, 76, 60, 0.1); }
    
    .tabs { display: flex; gap: 12px; margin-bottom: 20px; }
    .tab { padding: 10px 18px; border-radius: 12px; cursor: pointer; background: transparent; border: 1px solid transparent; color: var(--text); opacity:0.92; font-weight: 700; transition: all 0.12s ease; }
    .tab:hover { color: var(--text); transform: translateY(-2px); }
    .tab.active { background: linear-gradient(90deg,var(--primary),var(--accent)); color: white; border-color: transparent; box-shadow: 0 10px 30px rgba(37,99,235,0.12); }
    /* harmonized pill controls: lesson select + two toggles share the same palette */
    .tab.skill { background: linear-gradient(90deg,#7c3aed,#2563eb); color: white; border: 1px solid rgba(0,0,0,0.06); box-shadow: 0 8px 24px rgba(37,99,235,0.14); padding: 8px 14px; font-size: 0.98rem; height:40px; display:inline-flex; align-items:center; border-radius:12px; }
    .tab.skill:hover { transform: translateY(-2px); box-shadow: 0 12px 30px rgba(37,99,235,0.18); }
    .tab.skill.speaking-on { background: linear-gradient(90deg,#ef4444,#f97316); color: white; box-shadow: 0 10px 30px rgba(239,68,68,0.18); }

    /* lesson select styled to match toggles but slightly muted */
    .tab-select { padding: 6px 12px; border-radius: 12px; border: 1px solid rgba(124,58,237,0.12); background: linear-gradient(90deg, rgba(124,58,237,0.08), rgba(37,99,235,0.06)); color:var(--text); font-weight:700; height:40px; display:inline-flex; align-items:center; }
    .tabs select.tab-select { margin-right:10px; }
    
    .pagination { display: flex; justify-content: center; align-items: center; gap: 20px; margin-top: 10px; padding-bottom: 40px; }
    
    #backToTop {
      position: fixed; bottom: 30px; right: 30px; width: 50px; height: 50px;
      background: var(--primary); color: white; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; box-shadow: var(--shadow); border: none;
      opacity: 0; visibility: hidden; transition: 0.3s; z-index: 1000; font-size: 1.2rem;
    }
    #backToTop.show { opacity: 1; visibility: visible; }
    .hide { display: none; }
    .badge { background: var(--accent); color: white; padding: 6px 10px; border-radius: 999px; font-weight: 800; margin-left:10px; font-size:0.92rem; display:inline-flex; align-items:center; justify-content:center; }
    .badge.hide { display: none; }
  </style>
  <style>
    .shortcut-hint {
      text-align: center;
      font-size: 0.9rem;
      color: var(--muted);
      margin-top: 6px;
      margin-bottom: 12px;
      display: block;
    }
    .shortcut-hint strong { color: var(--text); }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>
<body data-theme="light">
  <div class="container">
    <header>
      <div style="display:flex; align-items:center; gap:12px">
        <div class="logo">4S</div>
        <div>
          <h1 style="margin:0; font-size: 1.5rem;">Translation Trainer</h1>
          <p style="margin:0; font-size: 0.8rem; color: var(--text);">Luy·ªán D·ªãch ‚Äî Translation Practice</p>
        </div>
      </div>
      <div style="display:flex; gap:10px; align-items:center">
        <button class="btn ghost" id="themeToggle" title="Chuy·ªÉn giao di·ªán s√°ng/t·ªëi">üåô</button>
        <select id="appSelectorHeader" onchange="if(this.value) window.location.href=this.value;" title="Ch·ªçn ·ª©ng d·ª•ng" style="margin-left:6px; padding:8px 10px; border-radius:8px; background:transparent; color: var(--text); border:1px solid rgba(255,255,255,0.04); font-weight:700;">
          <option value="">-- M·ªü ·ª©ng d·ª•ng --</option>
          <option value="EnglishPractice.html">English Practice</option>          
          <option value="TranslationTrainer.html" selected>Translation Trainer</option>
          <option value="test_offline.html">H·ªçc Ngo·∫°i Ng·ªØ</option>
        </select>
      </div>
    </header>

    <div class="tabs" style="align-items:center">
      <select id="lessonSelect" class="tab-select" autofocus tabindex="0">
        <option value="">-- Ch·ªçn b√†i h·ªçc --</option>
      </select>
      
      <button class="tab skill" id="toggleDirectionBtn" title="Chuy·ªÉn h∆∞·ªõng d·ªãch">H∆∞·ªõng: EN‚ÜíVI</button>
    </div>

    <div id="tabControlBar" class="control-panel" style="margin-bottom:14px;">
      <div style="display:flex; gap:8px; align-items:center; width:100%; justify-content:center; flex-wrap:wrap">
        <button class="btn ghost" id="centralPrev" title="Tr∆∞·ªõc">‚óÄ Tr∆∞·ªõc</button>
        <button class="btn ghost" id="centralRestart" title="B·∫Øt ƒë·∫ßu l·∫°i">üîÅ B·∫Øt ƒë·∫ßu l·∫°i</button>
        <button class="btn ghost" id="centralShowAnswer" title="Hi·ªán ƒë√°p √°n (Insert)">ƒê√°p √°n</button>

        
        <button class="btn ghost" id="centralNext" title="Ti·∫øp">Ti·∫øp ‚ñ∂</button>
        <button class="btn ghost" id="centralRepeat" title="L·∫∑p l·∫°i">üîÅ L·∫∑p l·∫°i</button>
      </div>
    </div>

    <div class="shortcut-hint" title="Ph√≠m t·∫Øt">
      Ph√≠m t·∫Øt: ‚Üê Tr∆∞·ªõc &nbsp;&middot;&nbsp; ‚Üí Ti·∫øp &nbsp;&middot;&nbsp; ‚Üë B·∫Øt ƒë·∫ßu l·∫°i &nbsp;&middot;&nbsp; ‚Üì L·∫∑p l·∫°i
    </div>

    <div id="exerciseArea"></div>

    <div id="pagination" class="pagination hide">
      <span id="pageInfo" style="font-weight: 600;">1 / 1</span>
      <span id="statusBar" style="font-weight:700; color:var(--muted);">Tr·∫°ng th√°i: Idle</span>
    </div>

    <div id="mainControlPanel" class="control-panel">
      <!-- lesson selector moved to tabs for quick access -->

      <div class="option-group">
        <span>T·ª∑ l·ªá ƒë√∫ng:</span>
        <input type="range" id="thresholdRange" min="50" max="100" step="1" value="100" title="ƒêi·ªÅu ch·ªânh ng∆∞·ª°ng gi·ªëng (50% - d·ªÖ, 100% - ho√†n to√†n ch√≠nh x√°c). T·∫≠p vi·∫øt n√™n ch·ªçn 100% ƒë·ªÉ y√™u c·∫ßu ch√≠nh x√°c tuy·ªát ƒë·ªëi">
        <span id="thresholdVal" style="margin-left:8px; font-weight:700;">100%</span>
        <span title="N·∫øu t·ª∑ l·ªá gi·ªëng (similarity) gi·ªØa c√¢u nh·∫≠p v√† ƒë√°p √°n l·ªõn h∆°n ho·∫∑c b·∫±ng gi√° tr·ªã n√†y s·∫Ω ƒë∆∞·ª£c ch·∫•m l√† ƒë√∫ng" style="margin-left:8px; color:var(--text);">‚ÑπÔ∏è</span>
      </div>

      <div class="option-group">
        <label style="display:flex; align-items:center; gap:8px; font-weight:600;"><input type="checkbox" id="listLoopCheckbox"> T·ª± l·∫∑p l·∫°i</label>
        <span id="wrongBadge" class="badge hide" title="S·ªë c√¢u c·∫ßn √¥n l·∫°i">0</span>
      </div>

      <div class="option-group">
        <span>Audio Engine:</span>
        <select id="audioEngineSelect" style="padding:8px; border-radius:6px;">
          <option value="gTTS">gTTS (Female US)</option>
          <option value="Edge">Edge TTS (Male US)</option>
        </select>
      </div>

      <!-- 'Luy·ªán N√≥i' button moved to the tabs area for visual parity with 'Luy·ªán Vi·∫øt' -->
      <div class="option-group">
        <span>Phi√™n:</span>
        <input type="number" id="sessionStartInput" min="1" value="1" style="width:70px; padding:6px; border-radius:6px;">
        <span> ƒë·∫øn </span>
        <input type="number" id="sessionEndInput" min="1" value="10" style="width:70px; padding:6px; border-radius:6px;">
        <button class="btn ghost" id="applySessionBtn" title="√Åp d·ª•ng ph·∫°m vi c√¢u cho phi√™n h·ªçc" style="margin-left:8px">√Åp d·ª•ng</button>
        <button class="btn ghost" id="bookmarkBtn" title="Bookmark v·ªã tr√≠ hi·ªán t·∫°i" style="margin-left:8px">üîñ L∆∞u</button>
        <button class="btn ghost" id="loadBookmarkBtn" title="T·∫£i bookmark" style="margin-left:6px">üìÇ T·∫£i</button>
      </div>
    </div>

    <!-- pagination moved above to sit directly under tabs -->
  </div>

  <button id="backToTop" title="L√™n ƒë·∫ßu trang">‚ñ≤</button>

  <script>
    let lessons = [];
    let currentLessonIdx = -1;
    let currentExIdx = 0;
    let isSingleMode = true;
    let isSpeakingMode = false; // d√πng cho luy·ªán n√≥i th·ª±c s·ª±
    let currentMode = 'sentence'; // sentence only for this trainer
    let recognition = null;
    let isRecognitionSupported = false;
    let willRestartRecognition = false;
    let isRecognitionRunning = false;
    let pauseSeconds = 0;
    let delayTimer = null;
    let isReadingModeActive = false;
    let matchThreshold = 1.0;
    let translationMode = 'en-vi'; // 'en-vi' or 'vi-en'
    let sessionStart = 0;
    let sessionEnd = 9;
    let sessionSize = 10;
    let listeningPauseSeconds = 2;
    let listeningIndex = 0;
    let isPreviewPlaying = false;
    let previewCanceled = false;
    let listeningAutoLoop = false;
    let readingAutoLoop = false;
    let sentenceAutoLoop = false;
    let dictationAutoAdvance = true;
    let dictationScheduledPlay = false;
    let lessonsMeta = [];
    let audioMapping = [];
    let currentHowl = null;
    let ttsAudio = null;
    let rewindSeconds = 3;
    // review helpers for EN‚ÜíVI writing flow
    let wrongQueue = []; // indices marked as 'Sai' during session
    let reviewQueue = []; // working queue used when reviewing after session
    let isReviewPhase = false; // true when reviewing wrongQueue after session end
    let awaitingJudgementIdx = null; // index of item currently awaiting ƒê√∫ng/Sai judgement

    function loadLessonList() {
      fetch('json_list.json')
        .then(res => res.json())
        .then(data => {
          lessonsMeta = data.lessons || [];
          [...lessonSelect.querySelectorAll('option')].filter(o => o.value && o.value.startsWith('remote:')).forEach(o => o.remove());
          lessonsMeta.forEach((m, i) => {
            const opt = document.createElement('option');
            opt.value = 'remote:' + i;
            opt.textContent = (m.name || '').replace('.json','');
            lessonSelect.appendChild(opt);
            console.log('Added remote lesson option', opt.value, opt.textContent);
          });
        })
        .catch(err => {
          console.log('Kh√¥ng th·ªÉ ƒë·ªçc json_list.json', err);
          // Fallback: try common local lessons in LESSON/ folder
          const fallbackFiles = ['2000_Daily_English.json','AnhMyThucDung.json'];
          fallbackFiles.forEach((fname) => {
            fetch('LESSON/' + fname)
              .then(r => {
                if (!r.ok) throw new Error('not found');
                const opt = document.createElement('option');
                opt.value = 'local:' + fname;
                opt.textContent = fname.replace('.json','');
                lessonSelect.appendChild(opt);
                console.log('Added local fallback option', opt.value, opt.textContent);
              })
              .catch(()=>{
                // ignore missing fallback file
              });
          });
        });
    }

    function loadLocalLesson(filename) {
      fetch('LESSON/' + filename)
        .then(r => r.json())
        .then(data => {
          const lessonObj = { title: filename, fill: [], sentence: [] };
          if (Array.isArray(data)) {
            data.forEach((row, ridx) => {
              const front = (row[0] || '').toString().trim();
              const frontIpa = (row[1] || '').toString().trim();
              const frontVi = row[2] || '';
              const back = (row[3] || '').toString().trim();
              const backIpa = (row[4] || '').toString().trim();
              const backVi = row[5] || '';
              lessonObj.fill.push({ id: ridx, question: front, answer: front, hint_vi: frontVi, ipa: frontIpa });
              if (front && back && front !== back) {
                lessonObj.sentence.push({ id: ridx*2, prompt: front, answer: front, prompt_vi: frontVi, ipa: frontIpa });
                lessonObj.sentence.push({ id: ridx*2 + 1, prompt: back, answer: back, prompt_vi: backVi, ipa: backIpa });
              } else {
                const text = back || front || '';
                const ipaText = back ? backIpa : frontIpa;
                lessonObj.sentence.push({ id: ridx, prompt: text, answer: text, prompt_vi: backVi || frontVi, ipa: ipaText });
              }
            });
          } else {
            lessonObj.fill = data.fill || data.items || [];
            lessonObj.sentence = data.sentence || [];
          }
          // add to lessons array as a single lesson and select it
          lessons.push(lessonObj);
          currentLessonIdx = lessons.length - 1;
          currentExIdx = 0;
          const totalItems = (lessonObj.sentence || []).length || 0;
          sessionStart = 0;
          sessionEnd = Math.max(0, totalItems - 1);
          sessionSize = Math.max(1, sessionEnd - sessionStart + 1);
          try {
            document.getElementById('sessionStartInput').value = totalItems > 0 ? 1 : 0;
            document.getElementById('sessionEndInput').value = totalItems > 0 ? (sessionEnd + 1) : 0;
          } catch (e) { }
          render();
        })
        .catch(err => console.error('L·ªói khi t·∫£i b√†i h·ªçc c·ª•c b·ªô:', err));
    }

    function loadRemoteLesson(idx) {
      const meta = lessonsMeta[idx];
      if (!meta) return;
      fetch('LESSON/' + meta.name)
        .then(r => r.json())
        .then(data => {
          const lessonObj = { title: meta.name, fill: [], sentence: [] };
          if (Array.isArray(data)) {
            data.forEach((row, ridx) => {
                const front = (row[0] || '').toString().trim();
                const frontIpa = (row[1] || '').toString().trim();
                const frontVi = row[2] || '';
                const back = (row[3] || '').toString().trim();
                const backIpa = (row[4] || '').toString().trim();
                const backVi = row[5] || '';
                lessonObj.fill.push({ id: ridx, question: front, answer: front, hint_vi: frontVi, ipa: frontIpa });
                if (front && back && front !== back) {
                  lessonObj.sentence.push({ id: ridx*2, prompt: front, answer: front, prompt_vi: frontVi, ipa: frontIpa });
                  lessonObj.sentence.push({ id: ridx*2 + 1, prompt: back, answer: back, prompt_vi: backVi, ipa: backIpa });
                } else {
                  const text = back || front || '';
                  const ipaText = back ? backIpa : frontIpa;
                  lessonObj.sentence.push({ id: ridx, prompt: text, answer: text, prompt_vi: backVi || frontVi, ipa: ipaText });
                }
            });
          } else {
            lessonObj.fill = data.fill || data.items || [];
            lessonObj.sentence = data.sentence || [];
          }

          if (meta.mapping) {
            fetch('LESSON/' + meta.mapping)
              .then(r => r.json())
              .then(map => { audioMapping = map || []; })
              .catch(e => { console.log('Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c mapping:', e); audioMapping = []; });
          } else {
            audioMapping = [];
          }

          lessons = [lessonObj];
          currentLessonIdx = 0;
          currentExIdx = 0;
          const totalItems = (lessonObj.sentence || []).length || 0;
          sessionStart = 0;
          sessionEnd = Math.max(0, totalItems - 1);
          sessionSize = Math.max(1, sessionEnd - sessionStart + 1);
          try {
            document.getElementById('sessionStartInput').value = totalItems > 0 ? 1 : 0;
            document.getElementById('sessionEndInput').value = totalItems > 0 ? (sessionEnd + 1) : 0;
          } catch (e) { }
          render();
        })
        .catch(err => console.error('L·ªói khi t·∫£i b√†i h·ªçc:', err));
    }

    const lessonSelect = document.getElementById('lessonSelect');
    const exerciseArea = document.getElementById('exerciseArea');
    const delayRange = document.getElementById('delayRange');
    

    // Handle lesson selection (remote list entries and local fallbacks)
    lessonSelect.addEventListener('change', (e) => {
      const v = e.target.value;
      console.log('lessonSelect change ->', v);
      if (!v) return;
      if (v.startsWith('remote:')) {
        const idx = parseInt(v.split(':')[1], 10);
        loadRemoteLesson(idx);
        return;
      }
      if (v.startsWith('local:')) {
        const fname = v.split(':').slice(1).join(':');
        loadLocalLesson(fname);
        return;
      }
      if (!isNaN(parseInt(v))) {
        currentLessonIdx = parseInt(v);
        currentExIdx = 0;
        try {
          const lesson = lessons[currentLessonIdx] || {};
          const total = (lesson.sentence || []).length || 0;
          sessionStart = 0;
          sessionEnd = Math.max(0, total - 1);
          sessionSize = Math.max(1, sessionEnd - sessionStart + 1);
          document.getElementById('sessionStartInput').value = total > 0 ? 1 : 0;
          document.getElementById('sessionEndInput').value = total > 0 ? (sessionEnd + 1) : 0;
        } catch (e) { }
        render();
        setTimeout(() => {
          try {
            const fi = document.getElementById(`input_${currentExIdx}`) || document.querySelector('#exerciseArea input[type="text"]');
            if (fi) { fi.focus(); if (typeof fi.select === 'function') fi.select(); }
          } catch (e) { }
        }, 120);
      }
    });

    if (delayRange) {
      delayRange.addEventListener('input', (e) => {
        const dv = document.getElementById('delayVal');
        if (dv) dv.textContent = (e.target.value / 1000).toFixed(1) + 's';
      });
    }

    document.getElementById('thresholdRange').addEventListener('input', (e) => {
      const val = parseInt(e.target.value, 10) || 100;
      document.getElementById('thresholdVal').textContent = val + '%';
      matchThreshold = val / 100;
    });

    const pauseSelectEl = document.getElementById('pauseSelect');
    if (pauseSelectEl) {
      pauseSelectEl.addEventListener('change', (e) => {
        pauseSeconds = parseInt(e.target.value, 10) || 2;
      });
    }

    const listPauseSelect = document.getElementById('listPauseSelect');
    if (listPauseSelect) {
      listPauseSelect.addEventListener('change', (e) => {
        listeningPauseSeconds = parseInt(e.target.value, 10) || 2;
      });
    }

    const listLoopCheckbox = document.getElementById('listLoopCheckbox');
    if (listLoopCheckbox) {
      listLoopCheckbox.addEventListener('change', (e) => { listeningAutoLoop = !!e.target.checked; });
    }

    if (listLoopCheckbox) {
      listLoopCheckbox.addEventListener('change', (e) => {
        const checked = !!e.target.checked;
        listeningAutoLoop = checked;
        readingAutoLoop = checked;
        sentenceAutoLoop = checked;
        const rcb = document.getElementById('readingLoopCheckbox'); if (rcb) rcb.checked = checked;
        const sb = document.getElementById('sentenceLoopCheckbox'); if (sb) sb.checked = checked;
        const lp = document.getElementById('lpAutoLoop'); if (lp) lp.checked = checked;
      });
    }

    document.getElementById('applySessionBtn').addEventListener('click', () => {
      const lesson = lessons[currentLessonIdx] || {};
      const total = (lesson.sentence || []).length || 0;
      let s = parseInt(document.getElementById('sessionStartInput').value, 10) || 1;
      let e = parseInt(document.getElementById('sessionEndInput').value, 10) || Math.min(s + sessionSize - 1, total);
      s = Math.max(1, Math.min(s, total));
      e = Math.max(s, Math.min(e, total));
      sessionStart = s - 1;
      sessionEnd = e - 1;
      sessionSize = sessionEnd - sessionStart + 1;
      currentExIdx = sessionStart;
      setStatus(`Phi√™n: ${s} - ${e}`, 'var(--muted)');
      render();
    });

    document.getElementById('bookmarkBtn').addEventListener('click', () => {
      if (currentLessonIdx === -1) return setStatus('Kh√¥ng c√≥ b√†i ƒë·ªÉ bookmark', 'var(--error)');
      const lesson = lessons[currentLessonIdx];
      const key = `bookmark_${lesson.title || 'lesson'}`;
      const payload = {
        sessionStart: sessionStart,
        sessionEnd: sessionEnd,
        sessionSize: sessionSize,
        current: currentExIdx,
        threshold: Math.round(matchThreshold * 100),
        listeningAutoLoop: !!listeningAutoLoop,
        readingAutoLoop: !!readingAutoLoop,
        sentenceAutoLoop: !!sentenceAutoLoop,
        isSingleMode: !!isSingleMode,
        currentMode: currentMode || 'reading'
      };
      try {
        localStorage.setItem(key, JSON.stringify(payload));
        try { localStorage.setItem('last_bookmark', JSON.stringify({ key, payload, page: window.location.pathname, ts: Date.now() })); } catch (e) { }
        setStatus('ƒê√£ l∆∞u bookmark', 'green');
      } catch (e) { setStatus('L∆∞u bookmark th·∫•t b·∫°i', 'var(--error)'); console.error('bookmark save error', e); }
    });

    document.getElementById('loadBookmarkBtn').addEventListener('click', () => {
      if (currentLessonIdx === -1) return setStatus('Kh√¥ng c√≥ b√†i ƒë·ªÉ t·∫£i bookmark', 'var(--error)');
      const lesson = lessons[currentLessonIdx];
      const key = `bookmark_${lesson.title || 'lesson'}`;
      try {
        let raw = localStorage.getItem(key);
        if (!raw) {
          const last = localStorage.getItem('last_bookmark');
          if (last) {
            try {
              const parsedLast = JSON.parse(last);
              raw = parsedLast && parsedLast.payload ? JSON.stringify(parsedLast.payload) : null;
              console.warn('Using fallback last_bookmark for restore');
            } catch (e) { }
          }
        }
        if (!raw) return setStatus('Kh√¥ng t√¨m th·∫•y bookmark', 'var(--muted)');
        const obj = JSON.parse(raw);
        sessionStart = (typeof obj.sessionStart === 'number') ? obj.sessionStart : 0;
        if (typeof obj.sessionEnd === 'number') {
          sessionEnd = Math.min(obj.sessionEnd, (lesson.sentence || []).length - 1);
        } else {
          sessionEnd = Math.min(sessionStart + sessionSize - 1, (lesson.sentence || []).length - 1);
        }
        sessionSize = (typeof obj.sessionSize === 'number') ? Math.max(1, Math.min(obj.sessionSize, (lesson.sentence || []).length)) : (sessionEnd - sessionStart + 1);
        currentExIdx = (typeof obj.current === 'number') ? obj.current : sessionStart;
        document.getElementById('sessionStartInput').value = sessionStart + 1;
        document.getElementById('sessionEndInput').value = sessionEnd + 1;
        if (typeof obj.threshold === 'number') {
          const perc = Math.max(50, Math.min(100, obj.threshold));
          document.getElementById('thresholdRange').value = perc;
          document.getElementById('thresholdVal').textContent = perc + '%';
          matchThreshold = perc / 100;
        }
        if (typeof obj.listeningAutoLoop === 'boolean') {
          listeningAutoLoop = obj.listeningAutoLoop;
          const globalAuto = document.getElementById('listLoopCheckbox'); if (globalAuto) globalAuto.checked = !!listeningAutoLoop;
        }
        if (typeof obj.readingAutoLoop === 'boolean') {
          readingAutoLoop = obj.readingAutoLoop;
          const readingCb = document.getElementById('readingLoopCheckbox'); if (readingCb) readingCb.checked = !!readingAutoLoop;
        }
        if (typeof obj.sentenceAutoLoop === 'boolean') {
          sentenceAutoLoop = obj.sentenceAutoLoop;
          const sentenceCb = document.getElementById('sentenceLoopCheckbox'); if (sentenceCb) sentenceCb.checked = !!sentenceAutoLoop;
        }
        if (typeof obj.isSingleMode === 'boolean') {
          isSingleMode = obj.isSingleMode;
          const viewBtn = document.getElementById('toggleViewMode'); if (viewBtn) {
            viewBtn.textContent = isSingleMode ? 'Ch·∫ø ƒë·ªô: C√¢u ƒë∆°n' : 'Ch·∫ø ƒë·ªô: T·∫•t c·∫£';
            viewBtn.classList.toggle('active-mode', !!isSingleMode);
          }
        }
        if (obj.currentMode) {
          currentMode = obj.currentMode;
          const tRead = document.getElementById('tabReading'); const tListen = document.getElementById('tabListeningPreview'); const tSent = document.getElementById('tabSentence');
          if (tRead) tRead.classList.toggle('active', currentMode === 'reading');
          if (tListen) tListen.classList.toggle('active', currentMode === 'listeningPreview');
          if (tSent) tSent.classList.toggle('active', currentMode === 'sentence');
        }
        setStatus('ƒê√£ t·∫£i bookmark', 'green');
        if (currentMode === 'reading') renderReading(); else render();
      } catch (e) { setStatus('T·∫£i bookmark l·ªói', 'var(--error)'); console.error('bookmark load error', e); }
    });

    function setStatus(text, color) {
      const label = document.getElementById('statusLabel');
      if (label) {
        label.textContent = 'Tr·∫°ng th√°i: ' + text;
        label.style.color = color || 'var(--muted)';
      }
      const sb = document.getElementById('statusBar');
      if (sb) {
        sb.textContent = 'Tr·∫°ng th√°i: ' + text;
        sb.style.color = color || 'var(--muted)';
      }
    }

    function cleanSpeech(str) {
      if (!str) return '';
      // normalize and remove diacritics (supports Vietnamese)
      // remove combining diacritical marks U+0300..U+036F after NFD normalization
      let s = str.toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
      s = s.replace(/\./g, "").replace(/:/g, "").replace(/a\s*m/g, "am").replace(/p\s*m/g, "pm").replace(/(\d+)00/g, "$1").replace(/everyday/g, "every day");
      // remove any remaining non-alphanumeric (keep a-z0-9 and whitespace)
      s = s.replace(/[^0-9a-z\s]/g, "");
      s = s.replace(/\s+/g, " ").trim();
      return s;
    }

    function levenshtein(a, b) {
      const an = a ? a.length : 0;
      const bn = b ? b.length : 0;
      if (an === 0) return bn;
      if (bn === 0) return an;
      const matrix = Array.from({ length: bn + 1 }, (_, i) => new Array(an + 1));
      for (let i = 0; i <= bn; i++) matrix[i][0] = i;
      for (let j = 0; j <= an; j++) matrix[0][j] = j;
      for (let i = 1; i <= bn; i++) {
        for (let j = 1; j <= an; j++) {
          const cost = a[j - 1] === b[i - 1] ? 0 : 1;
          matrix[i][j] = Math.min(
            matrix[i - 1][j] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j - 1] + cost
          );
        }
      }
      return matrix[bn][an];
    }

    function similarity(a, b) {
      const s1 = cleanSpeech((a || '').toString());
      const s2 = cleanSpeech((b || '').toString());
      if (!s1 && !s2) return 1;
      const dist = levenshtein(s1, s2);
      const max = Math.max(s1.length, s2.length);
      return max === 0 ? 1 : Math.max(0, 1 - dist / max);
    }

    function render() {
      exerciseArea.innerHTML = '';
      if (currentLessonIdx === -1) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Vui l√≤ng ch·ªçn b√†i h·ªçc ƒë·ªÉ b·∫Øt ƒë·∫ßu.</div>';
        document.getElementById('pagination').classList.add('hide');
        return;
      }
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const total = data.length;
      sessionStart = Math.max(0, Math.min(sessionStart, Math.max(0, total - 1)));
      sessionEnd = Math.max(sessionStart, Math.min(sessionEnd, total - 1));

      if (isSingleMode) {
        document.getElementById('pagination').classList.remove('hide');
        renderItem(data[currentExIdx], currentExIdx, total);
        const visibleCount = sessionEnd - sessionStart + 1;
        document.getElementById('pageInfo').textContent = `${currentExIdx - sessionStart + 1} / ${visibleCount} (t·ªïng ${total})`;
      } else {
        document.getElementById('pagination').classList.add('hide');
        for (let i = sessionStart; i <= sessionEnd; i++) {
          renderItem(data[i], i, total);
        }
      }
      const firstInput = exerciseArea.querySelector('input[type="text"], textarea, input[id^="input_"]');
      if (firstInput) {
        if (isSpeakingMode) {
          firstInput.placeholder = 'üé§ ƒêang nghe... h√£y n√≥i';
        } else {
          firstInput.placeholder = 'Nh·∫≠p c√¢u tr·∫£ l·ªùi...';
        }
        setTimeout(() => {
          try { firstInput.focus(); if (typeof firstInput.select === 'function') firstInput.select(); } catch (e) { }
        }, 50);
      }
    }

    function renderItem(item, idx, total) {
      if (!item) return;
      const div = document.createElement('div');
      div.className = 'exercise-item';
      // Determine source and target based on translationMode
      const englishText = item.prompt || item.answer || '';
      const vietnameseText = item.prompt_vi || item.hint_vi || '';
      const sourceText = (translationMode === 'en-vi') ? englishText : (vietnameseText || englishText);
      const targetText = (translationMode === 'en-vi') ? vietnameseText : englishText;
      const inputId = `input_${idx}`;
      const placeholder = (translationMode === 'en-vi') ? 'Nh·∫≠p b·∫£n d·ªãch ti·∫øng Vi·ªát...' : 'Nh·∫≠p b·∫£n d·ªãch ti·∫øng Anh...';

      div.innerHTML = `
        <div class="question" style="font-size:1.6rem;">${idx + 1}. ${sourceText}</div>
        <input type="text" id="${inputId}" style="font-size:1.18rem; padding:14px; text-align:center; display:block; width:90%; margin:12px auto;" placeholder="${placeholder}" autocomplete="off">
        <div class="feedback" id="fb_${idx}"></div>
        <div id="judgement_${idx}" style="margin-top:8px; display:none; gap:8px;">
          <button class="btn ghost" id="btn_review_${idx}" title="Xem l·∫°i (Delete)">Xem l·∫°i</button>
        </div>
      `;
      exerciseArea.appendChild(div);

      div.style.display = 'flex';
      div.style.flexDirection = 'column';
      div.style.alignItems = 'center';
      div.style.justifyContent = 'center';
      div.style.textAlign = 'center';
      div.style.minHeight = '120px';
      div.style.padding = '12px';

      const inputEl = document.getElementById(inputId);
      if (inputEl) {
        inputEl.style.padding = '10px';
        inputEl.style.fontSize = '1.02rem';
        inputEl.style.width = '90%';
      }

      const input = document.getElementById(inputId);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          clearTimeout(delayTimer);

          // Special flow for Luy·ªán Vi·∫øt (EN‚ÜíVI) when not in speaking mode:
          // Show the correct Vietnamese answer and present ƒê√∫ng / Sai buttons for user judgement.
          if (!isSpeakingMode && translationMode === 'en-vi' && currentMode === 'sentence') {
            showAnswerAndPlay(idx);
            return;
          }

          // Default behavior for other directions / modes: keep existing logic
          // Define answer processing so it runs only after source audio finishes
          const processAnswer = () => {
            const isCorrect = checkLogic(input.value, targetText);
            const fb = document.getElementById(`fb_${idx}`);

            if (isCorrect) {
              fb.className = 'feedback success';
              fb.innerHTML = `‚úÖ Ch√≠nh x√°c!${targetText ? `<br><span class="translation-hint"> ƒê√°p √°n: ${targetText}</span>` : ''}`;

              // Play English pronunciation of the target to reinforce correct form
              if (translationMode === 'vi-en' && targetText) {
                const enEntry = resolveAudioEntry(targetText);
                if (enEntry && enEntry.file) setTimeout(() => { stopAllAudio(); playAudioFor(targetText); }, 300);
                else setTimeout(() => { stopAllAudio(); speak(targetText, () => {}, 'en'); }, 300);
              }

              delayTimer = setTimeout(() => {
                if (isSingleMode) {
                  if (currentExIdx < sessionEnd) {
                    currentExIdx++; render();
                  } else {
                    if (sentenceAutoLoop) {
                      currentExIdx = sessionStart; render();
                    } else {
                      setStatus('Ho√†n th√†nh phi√™n', 'var(--muted)');
                    }
                  }
                } else {
                  const nextInput = document.getElementById(`input_${idx + 1}`);
                  if (nextInput) { nextInput.scrollIntoView({ behavior: 'smooth', block: 'center' }); nextInput.focus(); }
                }
              }, getDelayMs());
            } else {
              fb.className = 'feedback error';
              fb.textContent = targetText || '';
              // Also play the correct English pronunciation so learner can hear the target
              if (translationMode === 'vi-en' && targetText) {
                const enEntry2 = resolveAudioEntry(targetText);
                if (enEntry2 && enEntry2.file) setTimeout(() => { stopAllAudio(); playAudioFor(targetText); }, 300);
                else setTimeout(() => { stopAllAudio(); speak(targetText, () => {}, 'en'); }, 300);
              }
            }
          };

          // Play source audio and then process the answer to avoid overlapping voices
          if (translationMode === 'en-vi') {
            playAudioFor(sourceText, processAnswer);
          } else {
            // For VI‚ÜíEN we skip playing Vietnamese ‚Äî only evaluate and then play English pronunciation
            processAnswer();
          }
        }
      });
    }

    function checkLogic(userVal, correctVal) {
      return similarity(userVal, correctVal) >= matchThreshold;
    }

    // Show the Vietnamese answer (EN‚ÜíVI) and play the English pronunciation for reinforcement
    function showAnswerAndPlay(idx) {
      try {
        const lesson = lessons[currentLessonIdx] || {};
        const item = (lesson.sentence || [])[idx];
        if (!item) return;
        const sourceText = item.prompt || item.answer || '';
        const targetText = item.prompt_vi || item.hint_vi || '';

        const fb = document.getElementById(`fb_${idx}`);
        if (fb) {
          fb.className = 'feedback';
          fb.innerHTML = `<strong>${targetText || ''}</strong>`;
          try { fb.style.fontSize = '1.6rem'; fb.style.fontWeight = '700'; } catch (e) {}
        }
        const judgeDiv = document.getElementById(`judgement_${idx}`);
        if (judgeDiv) judgeDiv.style.display = 'flex';
        awaitingJudgementIdx = idx;

        const reviewBtn = document.getElementById(`btn_review_${idx}`);
        if (reviewBtn && !reviewBtn._wired) { reviewBtn.addEventListener('click', () => handleWrong(idx)); reviewBtn._wired = true; }

        // Prefer existing mapped audio file; otherwise use browser TTS (English)
        try {
          const enEntry = resolveAudioEntry(sourceText);
          if (enEntry && enEntry.file) { stopAllAudio(); playAudioFor(sourceText); }
          else { stopAllAudio(); speak(sourceText, () => {}, 'en'); }
        } catch (e) { console.log('showAnswerAndPlay error', e); }
      } catch (e) { console.log('showAnswerAndPlay outer error', e); }
    }

    function updateWrongBadge() {
      try {
        const el = document.getElementById('wrongBadge');
        if (!el) return;
        const count = (wrongQueue && wrongQueue.length) ? wrongQueue.length : 0;
        if (count > 0) { el.textContent = String(count); el.classList.remove('hide'); }
        else { el.textContent = '0'; el.classList.add('hide'); }
      } catch (e) { }
    }

    // Start review phase if there are wrong items queued after finishing session
    function startReviewIfNeeded() {
      if (isReviewPhase) return false;
      if (wrongQueue && wrongQueue.length > 0) {
        isReviewPhase = true;
        reviewQueue = wrongQueue.slice();
        wrongQueue = [];
        currentExIdx = reviewQueue.shift();
        setStatus('B·∫Øt ƒë·∫ßu √¥n l·∫°i c√°c c√¢u ƒë√£ ƒë√°nh d·∫•u Sai', 'var(--accent)');
        render();
        updateWrongBadge();
        return true;
      }
      return false;
    }

    function handleCorrect(idx) {
      awaitingJudgementIdx = null;
      // remove from any queues
      const wpos = wrongQueue.indexOf(idx); if (wpos !== -1) wrongQueue.splice(wpos,1);
      if (reviewQueue && reviewQueue.includes(idx)) {
        const rpos = reviewQueue.indexOf(idx); if (rpos !== -1) reviewQueue.splice(rpos,1);
      }
      updateWrongBadge();
      // advance depending on phase
      if (isReviewPhase) {
        if (reviewQueue.length > 0) {
          currentExIdx = reviewQueue.shift(); render();
        } else {
          isReviewPhase = false; setStatus('Ho√†n t·∫•t √¥n l·∫°i', 'green'); render();
        }
      } else {
        if (currentExIdx < sessionEnd) {
          currentExIdx++; render();
        } else {
          if (sentenceAutoLoop) { currentExIdx = sessionStart; render(); }
          else { if (!startReviewIfNeeded()) setStatus('Ho√†n th√†nh phi√™n', 'var(--muted)'); }
        }
      }
    }

    function handleWrong(idx) {
      awaitingJudgementIdx = null;
      if (!wrongQueue.includes(idx) && !(reviewQueue && reviewQueue.includes(idx))) wrongQueue.push(idx);
      updateWrongBadge();
      if (isReviewPhase) {
        if (reviewQueue.length > 0) { currentExIdx = reviewQueue.shift(); render(); }
        else { isReviewPhase = false; setStatus('Ho√†n t·∫•t √¥n l·∫°i', 'var(--muted)'); render(); }
      } else {
        if (currentExIdx < sessionEnd) { currentExIdx++; render(); }
        else {
          if (sentenceAutoLoop) { currentExIdx = sessionStart; render(); }
          else { if (!startReviewIfNeeded()) setStatus('Ho√†n th√†nh phi√™n', 'var(--muted)'); }
        }
      }
    }

    

    // Safe getter for delay (ms) ‚Äî accounts for removed control
    function getDelayMs() {
      try {
        if (typeof delayRange !== 'undefined' && delayRange && delayRange.value) return parseInt(delayRange.value, 10) || 1000;
      } catch (e) { }
      return 1000;
    }

    function stopAllAudio() {
      try { if (currentHowl) { try { currentHowl.stop(); currentHowl.unload(); } catch(e){} currentHowl = null; } } catch(e){}
      try { if (ttsAudio) { try { ttsAudio.pause(); } catch(e){} ttsAudio = null; } } catch(e){}
      try { if ('speechSynthesis' in window) { try { window.speechSynthesis.cancel(); } catch(e){} } } catch(e){}
      setStatus('Idle');
    }

    function resolveAudioEntry(text) {
      if (!text) return null;
      const trimmed = text.toString().trim();
      const preferred = getSelectedEngine();
      let entry = audioMapping.find(it => it.text && it.text.toString().trim() === trimmed && it.engine === preferred);
      if (entry) return entry;
      entry = audioMapping.find(it => it.text && it.text.toString().trim() === trimmed);
      return entry || null;
    }

    function getSelectedEngine() {
      const sel = document.getElementById('audioEngineSelect');
      if (!sel) return localStorage.getItem('preferred_tts_engine') || 'gTTS';
      return sel.value || (localStorage.getItem('preferred_tts_engine') || 'gTTS');
    }

    function playAudioFor(text, onComplete) {
      function _playTTS(t, lang, cb) {
        if (!t) { if (typeof cb === 'function') cb(); return; }
        speak(t, cb, lang);
      }

      if (!text) {
        if (typeof onComplete === 'function') onComplete();
        return;
      }
      const entry = resolveAudioEntry(text);
      if (entry && entry.file) {
        const path = ('LESSON/' + entry.file).replace(/\\/g, '/').replace(/\\/g, '/');
        try { if (currentHowl) { currentHowl.stop(); currentHowl.unload(); } } catch(e){}
        if (recognition && (isSpeakingMode || isReadingModeActive)) {
          willRestartRecognition = true;
          try { recognition.stop(); } catch(e) { console.log('stop recognition failed', e); }
        }
        setStatus('ƒêang ph√°t...', 'var(--primary)');
        currentHowl = new Howl({ src: [path], html5: true, onend: function() {
          setStatus(`ƒêang ch·ªù ${pauseSeconds}s`, 'var(--accent)');
          setTimeout(() => {
            if (typeof onComplete === 'function') {
              try { onComplete(); } catch (e) { console.log('onComplete error', e); }
            }
            willRestartRecognition = false;
            if (recognition && (isSpeakingMode || isReadingModeActive)) {
              try { if (!isRecognitionRunning) { recognition.start(); setStatus('ƒêang nghe...', 'green'); } } catch(e) { console.log('restart recognition failed', e); setStatus('L·ªói nghe', 'var(--error)'); }
            } else {
              setStatus('Idle');
            }
          }, pauseSeconds * 1000);
        }});
        currentHowl.play();
        return;
      }

      if (recognition && (isSpeakingMode || isReadingModeActive)) {
        willRestartRecognition = true;
        try { recognition.stop(); } catch(e) { console.log('stop recognition failed', e); }
      }
      setStatus('ƒêang ph√°t...', 'var(--primary)');
      // default to English TTS unless caller passed a language via a wrapper
      speak(text, () => {
        setStatus(`ƒêang ch·ªù ${pauseSeconds}s`, 'var(--accent)');
        setTimeout(() => {
          if (typeof onComplete === 'function') {
            try { onComplete(); } catch (e) { console.log('onComplete error', e); }
          }
          willRestartRecognition = false;
          if (recognition && (isSpeakingMode || isReadingModeActive)) {
            try { if (!isRecognitionRunning) { recognition.start(); setStatus('ƒêang nghe...', 'green'); } } catch(e) { console.log('restart recognition failed', e); setStatus('L·ªói nghe', 'var(--error)'); }
          } else {
            setStatus('Idle');
          }
        }, pauseSeconds * 1000);
      });
    }


    function speak(text, onEnded, lang = 'en') {
      if (!text) {
        if (typeof onEnded === 'function') onEnded();
        return;
      }
      // Prefer browser SpeechSynthesis (no CORS), fall back to existing audio approach if unavailable
      try {
        if ('speechSynthesis' in window) {
          try { window.speechSynthesis.cancel(); } catch (e) {}
          const ut = new SpeechSynthesisUtterance(text);
          // normalize language codes
          let langNorm = (lang || 'en').toString();
          if (langNorm === 'en') langNorm = 'en-US';
          if (langNorm === 'vi') langNorm = 'vi-VN';
          ut.lang = langNorm;
          ut.rate = 0.95;

          function pickVoiceAndSpeak() {
            const voices = window.speechSynthesis.getVoices() || [];
            let voice = null;
            if (voices.length > 0) {
              // exact startsWith match first
              voice = voices.find(v => v.lang && v.lang.toLowerCase().startsWith(langNorm.toLowerCase()));
              if (!voice) {
                const base = langNorm.split('-')[0].toLowerCase();
                voice = voices.find(v => v.lang && v.lang.toLowerCase().startsWith(base));
              }
              // fallback preferences: for English prefer en-US
              if (!voice && langNorm.startsWith('en')) {
                voice = voices.find(v => v.lang && v.lang.toLowerCase().startsWith('en-us')) || voices.find(v => v.lang && v.lang.toLowerCase().startsWith('en'));
              }
              // If no matching voice found and target is Vietnamese, prefer remote TTS to avoid English accent
              if (!voice && langNorm.startsWith('vi')) {
                // remote TTS play
                const url = `https://translate.google.com/translate_tts?ie=UTF-8&tl=${encodeURIComponent('vi')}&client=tw-ob&q=${encodeURIComponent(text)}`;
                try {
                  if (ttsAudio) { try { ttsAudio.pause(); } catch(e){} ttsAudio = null; }
                  ttsAudio = new Audio(url);
                  ttsAudio.crossOrigin = 'anonymous';
                  ttsAudio.play().catch(e => console.log("Audio play blocked", e));
                  ttsAudio.onended = function() { ttsAudio = null; if (typeof onEnded === 'function') onEnded(); };
                  return;
                } catch (e) { console.log('Remote VI TTS play error', e); }
              }
              if (!voice) voice = voices[0];
            }

            if (voice) ut.voice = voice;
            ut.onend = function() { if (typeof onEnded === 'function') onEnded(); };
            try { window.speechSynthesis.speak(ut); } catch (e) { console.log('speak error', e); if (typeof onEnded === 'function') onEnded(); }
          }

          // If voices haven't loaded yet, wait for them
          const available = window.speechSynthesis.getVoices() || [];
          if (!available || available.length === 0) {
            const handler = () => { pickVoiceAndSpeak(); window.speechSynthesis.removeEventListener('voiceschanged', handler); };
            window.speechSynthesis.addEventListener('voiceschanged', handler);
          } else {
            pickVoiceAndSpeak();
          }

          return;
        }
      } catch (e) {
        console.log('SpeechSynthesis error', e);
      }

      // Fallback: try to load remote TTS audio (may be blocked by CORS)
      const url = `https://translate.google.com/translate_tts?ie=UTF-8&tl=${encodeURIComponent(lang)}&client=tw-ob&q=${encodeURIComponent(text)}`;
      try {
        if (ttsAudio) {
          try { ttsAudio.pause(); } catch(e){}
          ttsAudio = null;
        }
        ttsAudio = new Audio(url);
        ttsAudio.crossOrigin = 'anonymous';
        ttsAudio.play().catch(e => console.log("Audio play blocked", e));
        ttsAudio.onended = function() { ttsAudio = null; if (typeof onEnded === 'function') onEnded(); };
      } catch (e) {
        console.log('TTS play error', e);
        ttsAudio = null;
        if (typeof onEnded === 'function') onEnded();
      }
    }

    function waitForAudioIdle(timeout = 15000) {
      return new Promise((resolve) => {
        const start = Date.now();
        const check = () => {
          try {
            if (currentHowl && typeof currentHowl.playing === 'function' && currentHowl.playing()) {
            } else if (ttsAudio && !ttsAudio.paused) {
            } else { resolve(); return; }
          } catch (e) { resolve(); return; }
          if (Date.now() - start > timeout) { resolve(); return; }
          setTimeout(check, 180);
        };
        check();
      });
    }

    const tabSentence = document.getElementById('tabSentence');
    if (tabSentence) {
      tabSentence.addEventListener('click', () => {
        currentMode = 'sentence';
        tabSentence.classList.add('active');
        isReadingModeActive = false;
        const mainCtrl = document.getElementById('mainControlPanel'); if (mainCtrl) mainCtrl.classList.remove('hide');
        const rp = document.getElementById('rolePlayingArea'); if (rp) rp.classList.add('hide');
        const ex = document.getElementById('exerciseArea'); if (ex) ex.classList.remove('hide');
        const pg = document.getElementById('pagination'); if (pg) pg.classList.remove('hide');
        render();
      });
    }

    // Speech recognition disabled ‚Äî provide harmless stubs to avoid runtime errors
    function initSpeechRecognition() {
      isRecognitionSupported = false;
      recognition = null;
    }

    function handleSpeechResult(text) {
      // Intentionally no-op because Luy·ªán N√≥i was removed
    }

    // Speech (Luy·ªán N√≥i) functionality removed ‚Äî stubs below to keep compatibility
    function startSpeechMode() { isSpeakingMode = false; setStatus('Ch·ª©c nƒÉng Luy·ªán N√≥i ƒë√£ b·ªã v√¥ hi·ªáu h√≥a', 'var(--muted)'); }
    function stopSpeechMode() { isSpeakingMode = false; }

    window.addEventListener('scroll', () => {
      document.getElementById('backToTop').classList.toggle('show', window.scrollY > 200);
    });
    document.getElementById('backToTop').addEventListener('click', () => window.scrollTo({top: 0}));

    // load server lessons list on startup
    loadLessonList();

    // initialize audio engine selector from localStorage
    const engineSel = document.getElementById('audioEngineSelect');
    if (engineSel) {
      const saved = localStorage.getItem('preferred_tts_engine');
      if (saved) engineSel.value = saved;
      engineSel.addEventListener('change', (e) => { localStorage.setItem('preferred_tts_engine', e.target.value); });
    }

    (function wireCentralControls(){
      const cPrev = document.getElementById('centralPrev');
      const cNext = document.getElementById('centralNext');
      const cRepeat = document.getElementById('centralRepeat');
      const cRestart = document.getElementById('centralRestart');
      const cShow = document.getElementById('centralShowAnswer');

      if (cPrev) cPrev.addEventListener('click', () => {
        if (currentMode === 'sentence') {
          if (currentExIdx > sessionStart) { currentExIdx--; render(); }
        }
      });

      if (cNext) cNext.addEventListener('click', () => {
        if (currentMode === 'sentence') {
          const lesson = lessons[currentLessonIdx] || {};
          const data = (lesson.sentence || []);
          const maxIdx = Math.min(sessionEnd, data.length - 1);
          if (currentExIdx < maxIdx) { currentExIdx++; render(); }
        }
      });

      // centralPlay removed; use Repeat (centralRepeat) instead

      // Keyboard shortcuts for central controls (skip when typing in inputs)
      function centralKeyHandler(e) {
        try {
          // ignore when modifier keys are pressed
          if (e.altKey || e.ctrlKey || e.metaKey) return;

          
          const ae = document.activeElement;
          const tag = ae && ae.tagName ? ae.tagName.toUpperCase() : '';
          const typing = tag === 'INPUT' || tag === 'TEXTAREA' || (ae && ae.isContentEditable);
          // allow arrow navigation even when focused inside answer inputs (ids like input_0)
          const isAnswerInput = typing && ae && ae.id && /^input_\d+$/.test(ae.id);
          if (typing && !isAnswerInput) return;

          // determine normalized key id (support legacy names and keyCode)
          const k = (e.key || '').toString();
          const code = (e.code || '').toString();
          const kc = e.keyCode || 0;
          let handled = false;

          // If awaiting judgement (ƒê√∫ng/Sai) allow quick keys: Home = ƒê√∫ng, End = Sai
          if (awaitingJudgementIdx !== null) {
            if (k === 'End' || code === 'End' || kc === 35) { handled = true; handleWrong(awaitingJudgementIdx); }
            if (handled) {
              try { e.preventDefault(); e.stopPropagation(); } catch (e) {}
              return;
            }
          }

          if (k === 'ArrowLeft' || code === 'ArrowLeft' || kc === 37 || k === 'Left') {
            handled = true; if (cPrev) { flashElement(cPrev); cPrev.click(); }
          } else if (k === 'ArrowRight' || code === 'ArrowRight' || kc === 39 || k === 'Right') {
            handled = true; if (cNext) { flashElement(cNext); cNext.click(); }
          } else if (k === 'Delete' || code === 'Delete' || kc === 46) {
            handled = true; if (cNext) { flashElement(cNext); cNext.click(); }
          } else if (k === 'ArrowUp' || code === 'ArrowUp' || kc === 38 || k === 'Up') {
            handled = true; if (cRestart) { flashElement(cRestart); cRestart.click(); }
          } else if (k === 'ArrowDown' || code === 'ArrowDown' || kc === 40 || k === 'Down') {
            handled = true; if (cRepeat) { flashElement(cRepeat); cRepeat.click(); }
          } else if (k === 'Insert' || code === 'Insert' || kc === 45) {
            handled = true;
            if (cShow) { flashElement(cShow); cShow.click(); }
          }

          if (handled) {
            try { e.preventDefault(); e.stopPropagation(); } catch (e) {}
          }
        } catch (err) { console.error('centralKeyHandler error', err); }
      }
      // Helper to briefly highlight a control for visual feedback
      function flashElement(el) {
        if (!el) return;
        const orig = el.style.boxShadow;
        el.style.boxShadow = '0 12px 30px rgba(0,0,0,0.18)';
        setTimeout(() => { el.style.boxShadow = orig; }, 220);
      }
      // Attach on window with capture to be more robust against other listeners
      // Only handle `keydown` to avoid duplicate handling from keyup (caused moving two items)
      window.addEventListener('keydown', centralKeyHandler, true);

      if (cRepeat) cRepeat.addEventListener('click', () => {
        if (currentMode === 'sentence') { const lesson = lessons[currentLessonIdx] || {}; const item = (lesson.sentence||[])[currentExIdx]; if (item) playAudioFor(item.answer || item.prompt || ''); }
      });

      if (cShow) cShow.addEventListener('click', () => {
        try {
          if (currentMode !== 'sentence') return;
          if (translationMode !== 'en-vi') return;
          showAnswerAndPlay(currentExIdx);
        } catch (e) { console.error('ShowAnswer handler error', e); }
      });

      if (cRestart) cRestart.addEventListener('click', () => {
        if (currentMode === 'sentence') { currentExIdx = sessionStart; render(); }
      });

      // centralLoopCheckbox removed from UI; global loop checkbox `listLoopCheckbox` controls behavior now
    })();

    // direction toggle
    const toggleDirectionBtn = document.getElementById('toggleDirectionBtn');
    if (toggleDirectionBtn) {
      toggleDirectionBtn.addEventListener('click', () => {
        translationMode = (translationMode === 'en-vi') ? 'vi-en' : 'en-vi';
        toggleDirectionBtn.textContent = translationMode === 'en-vi' ? 'H∆∞·ªõng: EN‚ÜíVI' : 'H∆∞·ªõng: VI‚ÜíEN';
        // re-render current item to update prompt/placeholder
        render();
      });
    }
  </script>
</body>
</html>